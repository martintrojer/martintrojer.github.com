<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>software on Martin Trojer</title>
    <link>https://martintrojer.github.io/categories/software/</link>
    <description>Recent content in software on Martin Trojer</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 18 Mar 2015 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://martintrojer.github.io/categories/software/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Software archaeology, hunting bugs in Emacs</title>
      <link>https://martintrojer.github.io/post/2015-03-18-software-archaeology-hunting-bugs-in-emacs/</link>
      <pubDate>Wed, 18 Mar 2015 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2015-03-18-software-archaeology-hunting-bugs-in-emacs/</guid>
      <description>&lt;p&gt;By reading the title of this post you might think this entry is about using some clever Emacs skills to find bugs in old software. But no, it&amp;rsquo;s actually about hunting down bugs in Emacs itself (which incidentally happens to be very old software).&lt;/p&gt;</description>
    </item>
    <item>
      <title>Moving my devboxes to Docker</title>
      <link>https://martintrojer.github.io/post/2015-02-22-moving-my-devboxes-to-docker/</link>
      <pubDate>Sun, 22 Feb 2015 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2015-02-22-moving-my-devboxes-to-docker/</guid>
      <description>&lt;p&gt;I&amp;rsquo;ve been quite vocal about my opinions on development environments and automating the creation of them &lt;a href=&#34;https://martintrojer.github.io/post/2014-12-04-developing-clojure-in-the-cloud/&#34;&gt;on this blog&lt;/a&gt; and &lt;a href=&#34;https://skillsmatter.com/skillscasts/6056-developing-clojure-in-the-cloud&#34;&gt;elsewhere&lt;/a&gt;. Boiling it down to the 2 points I feel most strongly about it would be;&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Always develop in a production-like environment&lt;/li&gt;&#xA;&lt;li&gt;Automate the creation of these environments&lt;/li&gt;&#xA;&lt;/ol&gt;</description>
    </item>
    <item>
      <title>Embedding a new runtime into your legacy C/C&#43;&#43; app</title>
      <link>https://martintrojer.github.io/post/2013-01-27-embedding-a-new-runtime-into-your-legacy-cc-app/</link>
      <pubDate>Sun, 27 Jan 2013 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2013-01-27-embedding-a-new-runtime-into-your-legacy-cc-app/</guid>
      <description>Let&amp;rsquo;s say you have a big / legacy C++ app, then you&amp;rsquo;re undoubtedly covered by Greenspun&amp;rsquo;s tenth rule. Let&amp;rsquo;s also say that your home-grown, buggy and slow DSL / scripting language has been pushed to the limit and can not be tweaked any further. What do you do, how can you replace it?&#xA;As you might expect, this is quite a common problem, and embedding scripting languages into a big C/C++ monolith is popular.</description>
    </item>
    <item>
      <title>What is a software company?</title>
      <link>https://martintrojer.github.io/post/2012-04-10-what-is-a-software-company/</link>
      <pubDate>Tue, 10 Apr 2012 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2012-04-10-what-is-a-software-company/</guid>
      <description>Software is different from most other things humans build, hence companies creating/selling/licensing software must be different from other &amp;lsquo;production&amp;rsquo; companies as well? Some definitely are but the vast majority are still trying to apply old civil engineering practices to software development. Why are they wasting so much time and money on upfront sizing, planning and tracking when all empirical evidence tells us it maps so badly to the actual process of developing software?</description>
    </item>
    <item>
      <title>Applied Symbolic Execution with KLEE/LLVM</title>
      <link>https://martintrojer.github.io/post/2011-11-10-applied-symbolic-execution-with-kleellvm/</link>
      <pubDate>Thu, 10 Nov 2011 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2011-11-10-applied-symbolic-execution-with-kleellvm/</guid>
      <description>This article serves as a follow-up to my previous post on symbolic execution, which can be found here. In this article, we will delve deeper into the details of KLEE and LLVM, discussing a potential practical application for a symbolic executor. We will also address some limitations and drawbacks associated with this approach.&#xA;If you&amp;rsquo;re interested in the changes we made for KLEE and LLVM, you can find them on GitHub.</description>
    </item>
    <item>
      <title>Is LLVM the beginning of the end for GNU (as we know it)?</title>
      <link>https://martintrojer.github.io/post/2011-11-08-is-llvm-the-beginning-of-the-end-for-gnu-as-we-know-it/</link>
      <pubDate>Tue, 08 Nov 2011 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2011-11-08-is-llvm-the-beginning-of-the-end-for-gnu-as-we-know-it/</guid>
      <description>GNU and Richard Stallman was a real catalyst for the open source movement and it&amp;rsquo;s crown jewel; the Linux kernel. Not only did Mr Torvalds early Linux releases have near 100% GNU &amp;ldquo;user-land&amp;rdquo;, he also decided to use release it under the GNU Public License; GPL. GNU and Stallman is forever linked with the birth and popularization of open source, and innovated both technically and legally by turning copyright laws on it&amp;rsquo;s head with the copy-left licenses.</description>
    </item>
    <item>
      <title>Symbolic Execution</title>
      <link>https://martintrojer.github.io/post/2011-11-02-symbolic-execution/</link>
      <pubDate>Wed, 02 Nov 2011 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2011-11-02-symbolic-execution/</guid>
      <description>A while back, I had the opportunity to collaborate with my colleague, Philippe Gabriel, on a research project focused on automating defect finding and enhancing overall test coverage. Our primary concern at the time was null pointer dereferences, which had the potential to cause system-wide crashes. In our quest, we explored various strategies and tools, both free and commercial. However, what truly captured our interest was a fascinating area of research called &amp;ldquo;Symbolic execution.</description>
    </item>
    <item>
      <title>What is software?</title>
      <link>https://martintrojer.github.io/post/2011-10-30-what-is-software/</link>
      <pubDate>Sun, 30 Oct 2011 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2011-10-30-what-is-software/</guid>
      <description>Having gained experience through numerous software projects and collaborations with diverse individuals, I&amp;rsquo;ve observed a recurring issue: a lack of understanding regarding the nature and process of software development. Surprisingly, even among developers, there persists a belief that seniority alone enables one to design and plan a problem, leaving less experienced developers to implement it. Some individuals still equate software development to assembly line production in the automotive industry.&#xA;In chapter 1 of &amp;ldquo;Structure and Interpretation of Computer Programs&amp;rdquo; SICP, Abelsson and Sussman describe a concept they call the &amp;ldquo;sorcerer&amp;rsquo;s spirit&amp;rdquo;</description>
    </item>
    <item>
      <title>Welcome and some guiding words...</title>
      <link>https://martintrojer.github.io/post/2011-10-29-welcome-and-some-guiding-words/</link>
      <pubDate>Sat, 29 Oct 2011 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2011-10-29-welcome-and-some-guiding-words/</guid>
      <description>Let&amp;rsquo;s begin with an inspiring quote from my favorite book on computer programming, &amp;ldquo;Structure and Interpretations of Computer Programs&amp;rdquo; (SICP) by Abelson and Sussman.&#xA;Underlying our approach to this subject (computer programming) is our conviction that “computer science” is not a science and that its significance has little to do with computers. The computer revolution is a revolution in the way we think and in the way we express what we think.</description>
    </item>
  </channel>
</rss>
