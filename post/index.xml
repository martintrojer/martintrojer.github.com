<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Martin Trojer</title>
    <link>https://martintrojer.github.io/post/</link>
    <description>Recent content in Posts on Martin Trojer</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 14 Jun 2016 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://martintrojer.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Some thoughts on clojure.spec</title>
      <link>https://martintrojer.github.io/post/2016-06-14-some-thoughts-on-clojurespec/</link>
      <pubDate>Tue, 14 Jun 2016 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2016-06-14-some-thoughts-on-clojurespec/</guid>
      <description>&lt;p&gt;Some of the readers of my &lt;a href=&#34;https://martintrojer.github.io/categories/beyond-clojure/&#34;&gt;Beyond Clojure&lt;/a&gt; blog series have asked about my opinion on clojure.spec, and if it solves Clojure&amp;rsquo;s &amp;rsquo;type problem&amp;rsquo;. Implying whether its presence makes me look more favorably on Clojure. Here are some of my thoughts.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Beyond ClojureScript: Elm</title>
      <link>https://martintrojer.github.io/post/2016-05-03-beyond-clojurescript-elm/</link>
      <pubDate>Tue, 03 May 2016 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2016-05-03-beyond-clojurescript-elm/</guid>
      <description>&lt;p&gt;This is a post in the &lt;a href=&#34;https://martintrojer.github.io/categories/beyond-clojure/&#34;&gt;Beyond Clojure&lt;/a&gt; blog series, in which a Clojure developer looks at typed languages for web app development. In this episode we look at front-end development in the language Elm.&lt;/p&gt;&#xA;&lt;p&gt;Front end development targeting web browsers is a ghetto, everybody seems to agree. The core tools at our disposal are the amalgamation of ideas and accidents thrown together without much overall strategy. One positive development in recent years has been the drastic improvement of the JavaScript (JS) engines in popular browsers. They have now gotten so good that its a valid option to treat JS as a compilation target. This fact is one of the drivers behind the explosion of JS transpilers, there are now literally hundreds of languages that (either primarily or as an after-though) can compile to JS. These languages range from light syntax improvements (ala &lt;a href=&#34;http://coffeescript.org/&#34;&gt;CoffeScript&lt;/a&gt;) to full blown languages with big runtimes and everything in between.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Beyond Clojure: Haskell</title>
      <link>https://martintrojer.github.io/post/2016-04-21-beyond-clojure-haskell/</link>
      <pubDate>Thu, 21 Apr 2016 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2016-04-21-beyond-clojure-haskell/</guid>
      <description>&lt;p&gt;This is a post in the  &lt;a href=&#34;https://martintrojer.github.io/categories/beyond-clojure/&#34;&gt;Beyond Clojure&lt;/a&gt; blog series, in which a Clojure developer looks at typed languages for web app development. This is by no means a complete survey of the Haskell web development landscape, rather a random collection of thoughts.&lt;/p&gt;&#xA;&lt;p&gt;If you are interested in typed functional languages one stands taller than the rest. Its impossible not to get sucked into the Haskell vortex, but why fight it? In spite of its reputation of being extremely hard to learn and even harder to master, there are several excellent resources out there and you are guaranteed to learn a lots of very valuable lessons.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Beyond Clojure: Prelude</title>
      <link>https://martintrojer.github.io/post/2016-04-19-beyond-clojure-prelude/</link>
      <pubDate>Tue, 19 Apr 2016 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2016-04-19-beyond-clojure-prelude/</guid>
      <description>&lt;p&gt;Here we are, after five years of learning and later doing Clojure full time, I&amp;rsquo;ve come to the point where I am seriously looking around for alternatives. I&amp;rsquo;ve gotten very comfortable working in Clojure, and it has and will continue to serve me very well. But getting comfortable has a flip-side, you stop caring.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Enable gzip with Ring and Jetty</title>
      <link>https://martintrojer.github.io/post/2015-10-04-enable-gzip-with-ring-and-jetty/</link>
      <pubDate>Sun, 04 Oct 2015 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2015-10-04-enable-gzip-with-ring-and-jetty/</guid>
      <description></description>
    </item>
    <item>
      <title>Datomic Do&#39;s and Don&#39;ts</title>
      <link>https://martintrojer.github.io/post/2015-06-03-datomic-dos-and-donts/</link>
      <pubDate>Wed, 03 Jun 2015 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2015-06-03-datomic-dos-and-donts/</guid>
      <description>&lt;p&gt;I recently tried to use Datomic in anger in a project, here are some things I learned.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Software archaeology, hunting bugs in Emacs</title>
      <link>https://martintrojer.github.io/post/2015-03-18-software-archaeology-hunting-bugs-in-emacs/</link>
      <pubDate>Wed, 18 Mar 2015 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2015-03-18-software-archaeology-hunting-bugs-in-emacs/</guid>
      <description>&lt;p&gt;By reading the title of this post you might think this entry is about using some clever Emacs skills to find bugs in old software. But no, it&amp;rsquo;s actually about hunting down bugs in Emacs itself (which incidentally happens to be very old software).&lt;/p&gt;</description>
    </item>
    <item>
      <title>Moving my devboxes to Docker</title>
      <link>https://martintrojer.github.io/post/2015-02-22-moving-my-devboxes-to-docker/</link>
      <pubDate>Sun, 22 Feb 2015 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2015-02-22-moving-my-devboxes-to-docker/</guid>
      <description>&lt;p&gt;I&amp;rsquo;ve been quite vocal about my opinions on development environments and automating the creation of them &lt;a href=&#34;https://martintrojer.github.io/post/2014-12-04-developing-clojure-in-the-cloud/&#34;&gt;on this blog&lt;/a&gt; and &lt;a href=&#34;https://skillsmatter.com/skillscasts/6056-developing-clojure-in-the-cloud&#34;&gt;elsewhere&lt;/a&gt;. Boiling it down to the 2 points I feel most strongly about it would be;&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Always develop in a production-like environment&lt;/li&gt;&#xA;&lt;li&gt;Automate the creation of these environments&lt;/li&gt;&#xA;&lt;/ol&gt;</description>
    </item>
    <item>
      <title>Clojure and Emacs without Cider redux</title>
      <link>https://martintrojer.github.io/post/2015-02-14-clojure-and-emacs-without-cider-redux/</link>
      <pubDate>Sat, 14 Feb 2015 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2015-02-14-clojure-and-emacs-without-cider-redux/</guid>
      <description>&lt;p&gt;Its been a couple of months since I&amp;rsquo;ve stopped using &lt;a href=&#34;https://github.com/clojure-emacs/cider&#34;&gt;Cider&lt;/a&gt; for Clojure development in Emacs. I find a simple &amp;lsquo;inferior lisp&amp;rsquo; setup faster and more reliable. For a good summary of why one would consider not using Cider, see &lt;a href=&#34;https://gist.github.com/levand/b1012bb7bdb5fcc6486f&#34;&gt;Luke VanderHart&amp;rsquo;s excellent summary&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Developing Clojure in the Cloud</title>
      <link>https://martintrojer.github.io/post/2014-12-04-developing-clojure-in-the-cloud/</link>
      <pubDate>Thu, 04 Dec 2014 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2014-12-04-developing-clojure-in-the-cloud/</guid>
      <description>&lt;p&gt;Recently I gave a talk at the &lt;a href=&#34;https://skillsmatter.com/conferences/1956-clojure-exchange-2014&#34;&gt;Clojure eXchange 2014&lt;/a&gt; titled &amp;lsquo;Developing Clojure in the Cloud&amp;rsquo;. I described a way of creating and using (Clojure) development environments inside VMs, I&amp;rsquo;ve been developing like this for the last year (spanning 2 projects).&lt;/p&gt;</description>
    </item>
    <item>
      <title>F#&#39;s strongest year yet</title>
      <link>https://martintrojer.github.io/post/2014-11-08-fs-strongest-year-yet/</link>
      <pubDate>Sat, 08 Nov 2014 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2014-11-08-fs-strongest-year-yet/</guid>
      <description>&lt;p&gt;Tradition demands that I write down some subjective thoughts on how my old friend F# is doing. So here we go again (for the 4th year running).&lt;/p&gt;&#xA;&lt;p&gt;All I can really say is this; wow, what a year.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Kebab-case keywords in nested Clojure data structures</title>
      <link>https://martintrojer.github.io/post/2014-10-18-kebab-case-keywords-in-nested-clojure-data-structures/</link>
      <pubDate>Sat, 18 Oct 2014 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2014-10-18-kebab-case-keywords-in-nested-clojure-data-structures/</guid>
      <description></description>
    </item>
    <item>
      <title>Clojure and Emacs without Cider</title>
      <link>https://martintrojer.github.io/post/2014-10-02-clojure-and-emacs-without-cider/</link>
      <pubDate>Thu, 02 Oct 2014 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2014-10-02-clojure-and-emacs-without-cider/</guid>
      <description>&lt;p&gt;I&amp;rsquo;ve been hacking Clojure for many years now, and I&amp;rsquo;ve been happy to rekindle my love for Emacs. The Clojure/Emacs tool-chain has come a long way during this time, swank-clojure, nREPL, nrepl.el and now Cider. The feature list is ever growing, and every-time you look there are some new awesome shortcut that will &amp;lsquo;make your day&amp;rsquo;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Book Review: Clojure Cookbook</title>
      <link>https://martintrojer.github.io/post/2014-04-06-book-review-clojure-cookbook/</link>
      <pubDate>Sun, 06 Apr 2014 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2014-04-06-book-review-clojure-cookbook/</guid>
      <description>The Clojure Cookbook is part of the O&amp;rsquo;Reilly cookbook series. I&amp;rsquo;d describe this format as a &amp;lsquo;curated wiki in print&amp;rsquo;. The wiki analogy is especially true for this volume since its contents was contributed by some 60 different developers. It&amp;rsquo;s packed with small bite-sized recipes for solving common problems in Clojure. This is useful for developers in the entire spectrum from beginner to expert.&#xA;The content is organized into 11 chapters each containing a number of recipes.</description>
    </item>
    <item>
      <title>The Clojure REPL; a blessing and a curse</title>
      <link>https://martintrojer.github.io/post/2014-04-05-the-clojure-repl-a-blessing-and-a-curse/</link>
      <pubDate>Sat, 05 Apr 2014 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2014-04-05-the-clojure-repl-a-blessing-and-a-curse/</guid>
      <description>&lt;p&gt;All Clojure developers swear by their REPL, its one of the most powerful tools in our arsenal. Coming from traditional edit/compile/launch languages it also a great productivity boost. The Clojure community takes non-aot (ahead of time compilation) to the extreme. By default, we ship Clojure source code in our development and production jars and thus leave compilation to the very last minute (when the program launches). This gives us lots of power and flexibility, if you ever navigated into a library in Emacs and fixed a bug, re-evaled the form and carried on working you know what I&amp;rsquo;m talking about.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Working with core.async: Blocking calls</title>
      <link>https://martintrojer.github.io/post/2014-03-09-working-with-coreasync-blocking-calls/</link>
      <pubDate>Sun, 09 Mar 2014 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2014-03-09-working-with-coreasync-blocking-calls/</guid>
      <description>&lt;p&gt;You can&amp;rsquo;t do anything even remotely blocking inside go-blocks. This is because all the core.async go blocks share a single thread pool, with a very limited number of threads (go blocks are supposed to be CPU bound). So if you have hundreds / thousands of go blocks running conurrently just having a few (a handful really) block &amp;ndash; &lt;em&gt;all&lt;/em&gt; go blocks will stop! For a more in-depth explanation see &lt;a href=&#34;https://martintrojer.github.io/post/2013-07-07-coreasync-and-blocking-io/&#34;&gt;this previous post&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Working with core.async: Chaining go blocks</title>
      <link>https://martintrojer.github.io/post/2014-03-09-working-with-coreasync-chaining-go-blocks/</link>
      <pubDate>Sun, 09 Mar 2014 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2014-03-09-working-with-coreasync-chaining-go-blocks/</guid>
      <description>&lt;p&gt;One particularly annoying difference between the core.async and &lt;a href=&#34;http://golang.org&#34;&gt;Go&lt;/a&gt; is that you can&amp;rsquo;t wrap function calls with the &lt;code&gt;go&lt;/code&gt; macro. This is due to implementation details of core.async, which can only see the body &amp;lsquo;inside&amp;rsquo; the macro and not the functions it may call. This is obviously not a problem if the called function doesn&amp;rsquo;t interact with any channels, but if it does when you might be in trouble. I&amp;rsquo;ve touched on this subject in a &lt;a href=&#34;https://martintrojer.github.io/post/2013-07-17-non-tailrecursive-functions-in-coreasync/&#34;&gt;previous post&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Working with core.async: Exceptions in go blocks</title>
      <link>https://martintrojer.github.io/post/2014-03-09-working-with-coreasync-exceptions-in-go-blocks/</link>
      <pubDate>Sun, 09 Mar 2014 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2014-03-09-working-with-coreasync-exceptions-in-go-blocks/</guid>
      <description>&lt;p&gt;Dealing with exceptions in go blocks/threads is different from normal clojure core. This gotcha is very common when moving your code into core.async go blocks &amp;ndash; all your exceptions are gone! Since the body of a go block is run on a thread pool, it&amp;rsquo;s not much we can do with an exception, thus core.async will just eat them and close the channel. That&amp;rsquo;s what happened in the second snippet &lt;a href=&#34;https://martintrojer.github.io/post/2014-03-09-working-with-coreasync-chaining-go-blocks/&#34;&gt;in this post&lt;/a&gt;. The &lt;code&gt;nil&lt;/code&gt; result is because the channel we read from is closed.&lt;/p&gt;</description>
    </item>
    <item>
      <title>This year in F#</title>
      <link>https://martintrojer.github.io/post/2013-10-29-this-year-in-f/</link>
      <pubDate>Tue, 29 Oct 2013 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2013-10-29-this-year-in-f/</guid>
      <description>&lt;p&gt;For the third year running, here&amp;rsquo;s my annual (and extremely subjective) review of the state of the F# language, its community and other loosely connected things. How would I sum up the noises coming from F# the last year? Pretty darn awesome. Alot of what&amp;rsquo;s been happening was on my wish-list outlined in &lt;a href=&#34;https://martintrojer.github.io/post/2012-10-24-the-future-of-net-lies-in-mono-the-future-of-f-lies-in-monodevelop/&#34;&gt;last year&amp;rsquo;s post&lt;/a&gt;. What are the highlights?&lt;/p&gt;</description>
    </item>
    <item>
      <title>Testing an API with Simulant</title>
      <link>https://martintrojer.github.io/post/2013-09-29-testing-an-api-with-simulant/</link>
      <pubDate>Sun, 29 Sep 2013 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2013-09-29-testing-an-api-with-simulant/</guid>
      <description>tl;dr I present a new Simulant example project, testing a simple web API.&#xA;All programs are simulation tested, atleast once. &amp;mdash; Stu Halloway&#xA;Simulating testing is an interesting field that has a lot going for it. While most web site/api developers write many tests at the unit level (an old Rails habit) testing and understanding a whole system is often not done. Most systems we build nowadays consists of many (mega/micro) services/databases glued together.</description>
    </item>
    <item>
      <title>Retrofitting the Reloaded pattern into Clojure projects</title>
      <link>https://martintrojer.github.io/post/2013-09-07-retrofitting-the-reloaded-pattern-into-clojure-projects/</link>
      <pubDate>Sat, 07 Sep 2013 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2013-09-07-retrofitting-the-reloaded-pattern-into-clojure-projects/</guid>
      <description>Stuart Sierra has done a great job with clojure.tools.namespace and the reloaded leiningen template. If you haven&amp;rsquo;t heard about this before please have a look at c.t.n readme and watch this presentation.&#xA;I&amp;rsquo;ve have retrofitted this pattern into two rather big clojure projects (20k and 5k lines) with several modules and here are some of my findings.&#xA;Removing global state The first step is to find all resources that needs to be &amp;ldquo;lifecycled&amp;rdquo;.</description>
    </item>
    <item>
      <title>Non tail-recursive functions in core.async go blocks</title>
      <link>https://martintrojer.github.io/post/2013-07-17-non-tailrecursive-functions-in-coreasync/</link>
      <pubDate>Wed, 17 Jul 2013 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2013-07-17-non-tailrecursive-functions-in-coreasync/</guid>
      <description>I&amp;rsquo;ve been using various Go examples / tutorials to take a deeper look into core.async. The CSP pattern is a very interesting and powerful, it&amp;rsquo;s good move for Clojure to &amp;ldquo;throw in&amp;rdquo; with Go and push this style of programming.&#xA;core.sync works at s-expression level, where some other JVM solutions (Kilim, Pulsar) do the same on byte code level. The main benefit of doing these transforms on s-expression level is that they are applicable to ClojureScript, where CSP can be a very neat way out of callback hell.</description>
    </item>
    <item>
      <title>core.async and Blocking IO</title>
      <link>https://martintrojer.github.io/post/2013-07-07-coreasync-and-blocking-io/</link>
      <pubDate>Sun, 07 Jul 2013 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2013-07-07-coreasync-and-blocking-io/</guid>
      <description>Some time ago I wrote about Asynchronous workflows in Clojure. With the recent release and excitement of core.async, I though it a good time to revisit that post.&#xA;While there are already some good example and comparison-with-go posts out there, I&amp;rsquo;d like to focus on an area often misunderstood, namely async frameworks and blocking APIs (most commonly blocking IO). It&amp;rsquo;s important to understand the implications of blocking IO and it&amp;rsquo;s effects on &amp;lsquo;async code&amp;rsquo;, in this case core.</description>
    </item>
    <item>
      <title>Datomic Bootstrap</title>
      <link>https://martintrojer.github.io/post/2013-07-05-datomic-bootstrap/</link>
      <pubDate>Fri, 05 Jul 2013 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2013-07-05-datomic-bootstrap/</guid>
      <description>&lt;p&gt;A simple SQL scenario;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Announcing Frins, a practical unit of measure calculator DSL for Scala</title>
      <link>https://martintrojer.github.io/post/2013-06-25-announcing-frins-a-practical-unit-of-measure-calculator-dsl-for-scala/</link>
      <pubDate>Tue, 25 Jun 2013 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2013-06-25-announcing-frins-a-practical-unit-of-measure-calculator-dsl-for-scala/</guid>
      <description>I am proud to announce a new Scala project called &amp;ldquo;Frins&amp;rdquo;.&#xA;Frins is a practical unit-of-measure calculator DSL for Scala.&#xA;Key features;&#xA;Tracks units of measure through all calculations allowing you to mix units of measure transparently Comes with a huge database of units and conversion factors Inspired by the Frink project Full source code available on github.&#xA;To wet your appetite head straight over to the example calculations.&#xA;How Frins came about About a year ago I created Frinj.</description>
    </item>
    <item>
      <title>EDN Parser in Scala</title>
      <link>https://martintrojer.github.io/post/2013-06-17-edn-parser-in-scala/</link>
      <pubDate>Mon, 17 Jun 2013 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2013-06-17-edn-parser-in-scala/</guid>
      <description>&lt;p&gt;Taken from &lt;a href=&#34;https://github.com/martintrojer/edn-scala&#34;&gt;edn-scala&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Scheme in Scala</title>
      <link>https://martintrojer.github.io/post/2013-06-06-scheme-in-scala/</link>
      <pubDate>Thu, 06 Jun 2013 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2013-06-06-scheme-in-scala/</guid>
      <description>In this post I present some of my experiences writing a Scheme interpreter in Scala (as an external DSL) and compare it with my recent similar experiences in Clojure and F#.&#xA;Overall, the Scala solution is very similar to the F# one. Not very surprising, since the problem lends itself well to case classes / discriminated union types and pattern matching. One difference is more type declarations in Scala, due to the lack of a Hindley-Milner type inference.</description>
    </item>
    <item>
      <title>Comparing FP REPL Sessions</title>
      <link>https://martintrojer.github.io/post/2013-06-04-comparing-fp-repl-sessions/</link>
      <pubDate>Tue, 04 Jun 2013 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2013-06-04-comparing-fp-repl-sessions/</guid>
      <description>Functional programming is great; higher-order functions, closures, immutable data-structures, lazy sequences etc.&#xA;Most languages comes with a REPL (or &amp;lsquo;interactive&amp;rsquo; prompt), where you can play with these features at your leisure. Dynamically typed languages are a bit more convenient in the REPL, but not by as much as you might think. Also, F# type providers closes the gap even further.&#xA;Here&amp;rsquo;s a typical, hit-a-JSON-endpoint-and-look-at-the-data session in Clojure;&#xA;$ lein repl user=&amp;gt; (def res (slurp &amp;#34;http://www.</description>
    </item>
    <item>
      <title>Scala and me</title>
      <link>https://martintrojer.github.io/post/2013-06-01-scala-and-me/</link>
      <pubDate>Sat, 01 Jun 2013 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2013-06-01-scala-and-me/</guid>
      <description>This epic journey (yeah right) began at Uni with discovering the mighty SICP, still the best book on programming I&amp;rsquo;ve read (and let&amp;rsquo;s face it, the best I will ever read). After that profound experience I kept an eye on the Lisp/FP world and wrote some toys in Scheme, ELisp, OCaml every now and then. One thing that dawned on me was that none of these languages had much practical use, they weren&amp;rsquo;t very applicable to real-world software problems.</description>
    </item>
    <item>
      <title>Clojure Hacking on the Samsung ARM Chromebook</title>
      <link>https://martintrojer.github.io/post/2013-04-06-clojure-on-the-samsung-arm-chromebook/</link>
      <pubDate>Sat, 06 Apr 2013 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2013-04-06-clojure-on-the-samsung-arm-chromebook/</guid>
      <description>I recently switched to the Samsung ARM Chromebook for all my laptop needs. The pitch it&amp;rsquo;s quite appealing, 200 quid, dual core ARM CortexA15s, good keyboard, totally fan-less (CPU is passively cooled), good battery life, 1kg weight. The one downside is it&amp;rsquo;s quite limited RAM size, just 2GB. But with a decent swap file, I&amp;rsquo;m running multiple JVMs (with Datomic, Elasicsearch, CLJS compiler etc without any hickups).&#xA;Out of the box it runs ChromeOS, which I have to say is pretty stellar for browsing and consuming content on the web.</description>
    </item>
    <item>
      <title>Flexible multi consumer/producer pipelines</title>
      <link>https://martintrojer.github.io/post/2013-03-16-flexible-multi-consumerproducer-pipelines/</link>
      <pubDate>Sat, 16 Mar 2013 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2013-03-16-flexible-multi-consumerproducer-pipelines/</guid>
      <description>TL;DR Pipejine - a lightweight Clojure library for multi-threaded producer/consumer pipelines supporting arbitrary DAG topologies.&#xA;Recently a colleague and I faced a problem where we needed to optimize the total running time of a complicated calculation. This calculation involved several asynchronous steps getting data from other systems (like elasticsearch and other home-grown services) and a bit of number crunching and tallying up the results at the end. Here is and simplified example of the system.</description>
    </item>
    <item>
      <title>Embedding a new runtime into your legacy C/C&#43;&#43; app</title>
      <link>https://martintrojer.github.io/post/2013-01-27-embedding-a-new-runtime-into-your-legacy-cc-app/</link>
      <pubDate>Sun, 27 Jan 2013 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2013-01-27-embedding-a-new-runtime-into-your-legacy-cc-app/</guid>
      <description>Let&amp;rsquo;s say you have a big / legacy C++ app, then you&amp;rsquo;re undoubtedly covered by Greenspun&amp;rsquo;s tenth rule. Let&amp;rsquo;s also say that your home-grown, buggy and slow DSL / scripting language has been pushed to the limit and can not be tweaked any further. What do you do, how can you replace it?&#xA;As you might expect, this is quite a common problem, and embedding scripting languages into a big C/C++ monolith is popular.</description>
    </item>
    <item>
      <title>The M Word</title>
      <link>https://martintrojer.github.io/post/2012-11-24-the-m-word/</link>
      <pubDate>Sat, 24 Nov 2012 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2012-11-24-the-m-word/</guid>
      <description></description>
    </item>
    <item>
      <title>The future of .NET lies in Mono. The future of F# lies in MonoDevelop.</title>
      <link>https://martintrojer.github.io/post/2012-10-24-the-future-of-net-lies-in-mono-the-future-of-f-lies-in-monodevelop/</link>
      <pubDate>Wed, 24 Oct 2012 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2012-10-24-the-future-of-net-lies-in-mono-the-future-of-f-lies-in-monodevelop/</guid>
      <description>It&amp;rsquo;s been a year since I last wrote about F# and Mono - what&amp;rsquo;s happened since then?&#xA;F# 3.0 has recently been released, bundled in with the new all-grey, ALL-CAPS Visual Studio 2012. The biggest new feature is type providers, bringing some of the benefits of dynamic languages into type safe world. Innovations like type providers deserve more industry attention. I really hope these ideas will spread and hopefully languages like Scala will pick them up pretty soon so more developers (including me) can enjoy the benefits.</description>
    </item>
    <item>
      <title>Some core.logic graph code</title>
      <link>https://martintrojer.github.io/post/2012-09-27-some-corelogic-graph-code/</link>
      <pubDate>Thu, 27 Sep 2012 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2012-09-27-some-corelogic-graph-code/</guid>
      <description></description>
    </item>
    <item>
      <title>Some more Datalog</title>
      <link>https://martintrojer.github.io/post/2012-08-28-some-more-datalog/</link>
      <pubDate>Tue, 28 Aug 2012 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2012-08-28-some-more-datalog/</guid>
      <description>I&amp;rsquo;ve written about datalog and Datomic a bit recently. To conclude here&amp;rsquo;s another post comparing execution speed with the contrib.datalog library, by Jeffrey Straszheim. Clojure1.4 ready source can be found here.&#xA;The example I&amp;rsquo;m using in my benchmark is a simple join between two relations, in datomic/datalog it would look like this;&#xA;(q &amp;#39;[:find ?first ?height :in $a $b :where [$a ?last ?first ?email] [$b ?email ?height]] [[&amp;#34;Doe&amp;#34; &amp;#34;John&amp;#34; &amp;#34;jdoe@example.com&amp;#34;] [&amp;#34;Doe&amp;#34; &amp;#34;Jane&amp;#34; &amp;#34;jane@example.</description>
    </item>
    <item>
      <title>cKanren time!</title>
      <link>https://martintrojer.github.io/post/2012-08-12-ckanren-time/</link>
      <pubDate>Sun, 12 Aug 2012 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2012-08-12-ckanren-time/</guid>
      <description>Mr David Nolen recently published core.logic 0.8.alpha2, with added cKanren (c for constraints) support. To celebrate this glorious event I&amp;rsquo;m writing up some core.logic/cKanren stuff I&amp;rsquo;ve been looking at recently.&#xA;Enter the Queens If you&amp;rsquo;ve followed this blog, you&amp;rsquo;ve perhaps seen my previous posts on solving N-Queens in core.logic (part1 and part2). How will this look and perform using the new shiny cKanren extensions in core.logic 0.8? Obviously there are many (new) ways to solve this problem, here&amp;rsquo;s a core.</description>
    </item>
    <item>
      <title>Untying the Recursive Knot</title>
      <link>https://martintrojer.github.io/post/2012-07-23-untying-the-recursive-knot/</link>
      <pubDate>Mon, 23 Jul 2012 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2012-07-23-untying-the-recursive-knot/</guid>
      <description>Here I present a couple of examples of the functional design pattern &amp;ldquo;untying the recursive knot&amp;rdquo;. I&amp;rsquo;ve found this useful in a couple of occasions, for instance when breaking apart mutually recursive functions. Material inspired by Jon Harrop&amp;rsquo;s excellent Visual F# to Technical Computing.&#xA;First, let&amp;rsquo;s look at a simple factorial implementation using direct recursion;&#xA;(defn fact [n] (if (= n 0) 1 (* n (fact (dec n))))) We can break the direct recursive dependency by replacing the recursive calls with calls to a function argument;</description>
    </item>
    <item>
      <title>Replicating Datomic/Datalog queries with core.logic, take 2</title>
      <link>https://martintrojer.github.io/post/2012-07-17-replicating-datomicdatalog-queries-with-corelogic-take-2/</link>
      <pubDate>Tue, 17 Jul 2012 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2012-07-17-replicating-datomicdatalog-queries-with-corelogic-take-2/</guid>
      <description>This is a follow-up to my previous post on datalog-equivalent queries in core.logic.&#xA;Here I present an alternate way to do the unification and join inside core.logic (without having to use clojure.set/join). It uses the the relationships / facts API in core logic, described here. First let&amp;rsquo;s consider this datomic query;&#xA;(q &amp;#39;[:find ?first ?height :in [[?last ?first ?email]] [[?email ?height]]] [[&amp;#34;Doe&amp;#34; &amp;#34;John&amp;#34; &amp;#34;jdoe@example.com&amp;#34;] [&amp;#34;Doe&amp;#34; &amp;#34;Jane&amp;#34; &amp;#34;jane@example.com&amp;#34;]] [[&amp;#34;jane@example.com&amp;#34; 73] [&amp;#34;jdoe@example.com&amp;#34; 71]]) ;; #&amp;lt;HashSet [[&amp;#34;Jane&amp;#34; 73], [&amp;#34;John&amp;#34; 71]]&amp;gt; In core.</description>
    </item>
    <item>
      <title>Replicating Datomic/Datalog queries with core.logic</title>
      <link>https://martintrojer.github.io/post/2012-07-16-replicating-datomicdatalog-queries-with-corelogic/</link>
      <pubDate>Mon, 16 Jul 2012 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2012-07-16-replicating-datomicdatalog-queries-with-corelogic/</guid>
      <description>I&amp;rsquo;ve been toying with Datomic recently, and I particularly like the power of it&amp;rsquo;s query language (~Datalog). Mr Halloway showed a couple of months ago how the query engine is generic enough to be run on standard Clojure collections, gist here. Here is an example from that page of a simple join;&#xA;(q &amp;#39;[:find ?first ?height :in [[?last ?first ?email]] [[?email ?height]]] [[&amp;#34;Doe&amp;#34; &amp;#34;John&amp;#34; &amp;#34;jdoe@example.com&amp;#34;] [&amp;#34;Doe&amp;#34; &amp;#34;Jane&amp;#34; &amp;#34;jane@example.com&amp;#34;]] [[&amp;#34;jane@example.com&amp;#34; 73] [&amp;#34;jdoe@example.</description>
    </item>
    <item>
      <title>N Queens with core.logic, take 2</title>
      <link>https://martintrojer.github.io/post/2012-07-11-n-queens-with-corelogic-take-2/</link>
      <pubDate>Wed, 11 Jul 2012 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2012-07-11-n-queens-with-corelogic-take-2/</guid>
      <description>This post is a follow-up to my previous post on NQueens and core.logic, in which I tried to find the solutions using &amp;ldquo;pure&amp;rdquo; logic (without arithmetic goals) and basic minKanren / Reasoner Schemer building blocks.&#xA;After some excellent feedback and hints from Mr David Nolen (big thanks), I here present a greatly simplified (and faster) way of using core.logic to find all solutions. Credit also goes to good old Bratko.</description>
    </item>
    <item>
      <title>N Queens with core.logic, take 1</title>
      <link>https://martintrojer.github.io/post/2012-07-07-n-queens-with-corelogic-take-1/</link>
      <pubDate>Sat, 07 Jul 2012 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2012-07-07-n-queens-with-corelogic-take-1/</guid>
      <description>I&amp;rsquo;ve been &amp;ldquo;hammock-reading&amp;rdquo; the excellent Reasoned Schemer book the last couple of months, on my quest trying to develop a gut feel for when logic programming, as defined by miniKanren/core.logic, is applicable.&#xA;My first attempt is to apply it to a problem where (as it turns out) miniKanren isn&amp;rsquo;t a good fit, n-queens. What you really need for this, in logical programming world, for this problem is something called contraint logic programming (CLP) which is implemented (for example) in cKanren.</description>
    </item>
    <item>
      <title>Some thoughts on logging</title>
      <link>https://martintrojer.github.io/post/2012-07-03-some-thoughts-on-logging/</link>
      <pubDate>Tue, 03 Jul 2012 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2012-07-03-some-thoughts-on-logging/</guid>
      <description>Have you ever tried to log from multi threaded program? Have you tried to make sense of the log output which multiple subsystems were logging to? Have you tried to do average latency calculations based on that log file?&#xA;If you reading this blog, I am guessing you answered yes to a couple of the questions above.&#xA;There are multiple problems here; multiple producers (race conditions), out-of-order logs, conflated subsystem in the same logs etc.</description>
    </item>
    <item>
      <title>Distributed Actors in Clojure</title>
      <link>https://martintrojer.github.io/post/2012-05-17-distributed-actors-in-clojure/</link>
      <pubDate>Thu, 17 May 2012 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2012-05-17-distributed-actors-in-clojure/</guid>
      <description>Here&amp;rsquo;s another post on a topic that have been discussed since the dawn-of-time, is there is nice and idiomatic way to write Erlang/Actor style distributed programs in Clojure? There has certainly been a few attempts, but Rich&amp;rsquo;s post (above) still holds true today.&#xA;First some clarification; I am not primarily thinking about number-crunching, map/reduce-y stuff, where Clojure has a pretty good story;&#xA;clojure-hadoop swamiji cacalog zookeeper-clj storm etc&amp;hellip; Akka and the Erlang legacy I am trying to write programs that solve problems in the areas where Erlang typically excels such as</description>
    </item>
    <item>
      <title>What is a software company?</title>
      <link>https://martintrojer.github.io/post/2012-04-10-what-is-a-software-company/</link>
      <pubDate>Tue, 10 Apr 2012 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2012-04-10-what-is-a-software-company/</guid>
      <description>Software is different from most other things humans build, hence companies creating/selling/licensing software must be different from other &amp;lsquo;production&amp;rsquo; companies as well? Some definitely are but the vast majority are still trying to apply old civil engineering practices to software development. Why are they wasting so much time and money on upfront sizing, planning and tracking when all empirical evidence tells us it maps so badly to the actual process of developing software?</description>
    </item>
    <item>
      <title>Enumerate N Queens solutions</title>
      <link>https://martintrojer.github.io/post/2012-03-25-enumerate-n-queens-solutions/</link>
      <pubDate>Sun, 25 Mar 2012 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2012-03-25-enumerate-n-queens-solutions/</guid>
      <description></description>
    </item>
    <item>
      <title>Adding Live Unit Feeds to Frinj</title>
      <link>https://martintrojer.github.io/post/2012-03-14-adding-live-unit-feeds-to-frinj/</link>
      <pubDate>Wed, 14 Mar 2012 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2012-03-14-adding-live-unit-feeds-to-frinj/</guid>
      <description>A couple of weeks has passed since I&amp;rsquo;ve pushed Frinj to github and blogged/tweeted about it. The response have been pretty awesome, one highlight being when @stuarthalloway showed me a frinj+datomic example gist on the #datomic IRC channel. In short, the Clojure community is #badass.&#xA;Frinj comes with a big database of units and conversion factors, and while as many conversion factors are &amp;ldquo;eternal&amp;rdquo;, others aren&amp;rsquo;t. Exchange rates for instance has to be kept up to date to be relevant.</description>
    </item>
    <item>
      <title>Announcing Frinj, a practical unit of measure calculator DSL for Clojure</title>
      <link>https://martintrojer.github.io/post/2012-03-03-announcing-frinj-a-practical-unit-of-measure-calculator-dsl-for-clojure/</link>
      <pubDate>Sat, 03 Mar 2012 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2012-03-03-announcing-frinj-a-practical-unit-of-measure-calculator-dsl-for-clojure/</guid>
      <description>I am proud to announce a new Clojure project called &amp;ldquo;Frinj&amp;rdquo;.&#xA;Frinj is a practical unit-of-measure calculator DSL for Clojure.&#xA;Key features;&#xA;Tracks units of measure through all calculations allowing you to mix units of measure transparently Comes with a huge database of units and conversion factors Inspired by the Frink project Tries to combine Frink&amp;rsquo;s fluent calculation style with idiomatic Clojure Full source code available on github.&#xA;To wet your apatite head straight over to the sample calculations page to see what Frinj can do!</description>
    </item>
    <item>
      <title>ASCII Mandelbrot Set</title>
      <link>https://martintrojer.github.io/post/2012-02-21-ascii-mandelbrot-set/</link>
      <pubDate>Tue, 21 Feb 2012 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2012-02-21-ascii-mandelbrot-set/</guid>
      <description></description>
    </item>
    <item>
      <title>Some thoughts on Clojure performance</title>
      <link>https://martintrojer.github.io/post/2012-02-18-some-thoughts-on-clojure-performance/</link>
      <pubDate>Sat, 18 Feb 2012 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2012-02-18-some-thoughts-on-clojure-performance/</guid>
      <description>Edit: This post recently re-surfaced on hacker news and caused a bit of a stir, mainly because of a slightly sensational/misleading title (was &amp;ldquo;Why is Clojure so slow?&amp;rdquo;). I wrote this before Rich Hickey&amp;rsquo;s Clojure/Conj 2011 keynote was published, in which he talks about most of my concerns (and outlines possible solutions).&#xA;Clojure is great in many ways, but one thing it can&amp;rsquo;t be accused of is being particularly fast. What I mean by fast here is the speed in which Clojure programs execute.</description>
    </item>
    <item>
      <title>Scheme as an external DSL in Clojure</title>
      <link>https://martintrojer.github.io/post/2012-01-28-scheme-as-an-external-dsl-in-clojure/</link>
      <pubDate>Sat, 28 Jan 2012 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2012-01-28-scheme-as-an-external-dsl-in-clojure/</guid>
      <description>This is a follow-up post to my previous &amp;ldquo;Scheme in Clojure&amp;rdquo; post.&#xA;This time we implement a Scheme interpreter as an external DSL. This means that we consider the DSL as completely foreign to the host language, so we need to write our own parser (or reader as it&amp;rsquo;s called in Clojure) and interpreter. I have to admit that this is a bit of an academic exercise because the internal DSL version I wrote about previously is both smaller (less code) and faster (as fast as any other Clojure code).</description>
    </item>
    <item>
      <title>Asynchronous workflows in Clojure</title>
      <link>https://martintrojer.github.io/post/2011-12-22-asynchronous-workflows-in-clojure/</link>
      <pubDate>Thu, 22 Dec 2011 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2011-12-22-asynchronous-workflows-in-clojure/</guid>
      <description>Asynchronous workflows is a very powerful feature of F#, and recently I wanted to explore the state of the JVM and in particular Clojure when it comes to replicate the functionality. In this post I&amp;rsquo;ll share some of my findings and I&amp;rsquo;ll include some background material to explain the problems.&#xA;Let&amp;rsquo;s start with an example of a webclient using &amp;ldquo;async&amp;rdquo; in F#.&#xA;let download url = async { let request = HttpWebRequest.</description>
    </item>
    <item>
      <title>Parsing with Matches and Banana Clips</title>
      <link>https://martintrojer.github.io/post/2011-12-03-parsing-with-matches-and-banana-clips/</link>
      <pubDate>Sat, 03 Dec 2011 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2011-12-03-parsing-with-matches-and-banana-clips/</guid>
      <description>I find myself working with DSLs quite a bit, and thus I write a few parsers. Some languages are better than others for parsers and pattern matching is a technique that makes writing parsers a true joy. I will not go over the basics of pattern matching here, rather show how F#&amp;rsquo;s active patterns can be used to take pattern matching to the next level.&#xA;The traditional steps of a &amp;ldquo;parser&amp;rdquo; are roughly lexical analysis (tokenizer), syntactic analysis (parser) and then evaluator (interpreter).</description>
    </item>
    <item>
      <title>Scheme as an embedded DSL in Clojure</title>
      <link>https://martintrojer.github.io/post/2011-11-29-scheme-as-an-embedded-dsl-in-clojure/</link>
      <pubDate>Tue, 29 Nov 2011 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2011-11-29-scheme-as-an-embedded-dsl-in-clojure/</guid>
      <description>If you give someone Fortran, he has Fortran.&#xA;If you give someone Lisp, he has any language he pleases.&#xA;&amp;ndash; Guy Steele&#xA;Replace Fortran with whatever language you are currently using, and the quote still holds true today. Lisp has been around for a long time, and it&amp;rsquo;s built in flexibility is still unmatched by other languages. In this post we will look at key Lisp concepts such as code-is-data and powerful macro semantics.</description>
    </item>
    <item>
      <title>Tail Calls in F#, Clojure and Scala</title>
      <link>https://martintrojer.github.io/post/2011-11-20-tail-calls-in-f-clojure-and-scala/</link>
      <pubDate>Sun, 20 Nov 2011 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2011-11-20-tail-calls-in-f-clojure-and-scala/</guid>
      <description>I recently looked into Tail Call Optimisation/Elimination (TCO) and the implications for 3 modern languages, namely F#, Clojure and Scala. In this post I share my my findings. If you&amp;rsquo;re new to the subject or just looking into some of these languages I hope this post can be of some use to you. I will mix code snippets in the 3 languages freely (and without warning! :)&#xA;TCO is a well documented topic in books and articles about functional programming and the TCO in .</description>
    </item>
    <item>
      <title>Applied Symbolic Execution with KLEE/LLVM</title>
      <link>https://martintrojer.github.io/post/2011-11-10-applied-symbolic-execution-with-kleellvm/</link>
      <pubDate>Thu, 10 Nov 2011 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2011-11-10-applied-symbolic-execution-with-kleellvm/</guid>
      <description>This article serves as a follow-up to my previous post on symbolic execution, which can be found here. In this article, we will delve deeper into the details of KLEE and LLVM, discussing a potential practical application for a symbolic executor. We will also address some limitations and drawbacks associated with this approach.&#xA;If you&amp;rsquo;re interested in the changes we made for KLEE and LLVM, you can find them on GitHub.</description>
    </item>
    <item>
      <title>Is LLVM the beginning of the end for GNU (as we know it)?</title>
      <link>https://martintrojer.github.io/post/2011-11-08-is-llvm-the-beginning-of-the-end-for-gnu-as-we-know-it/</link>
      <pubDate>Tue, 08 Nov 2011 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2011-11-08-is-llvm-the-beginning-of-the-end-for-gnu-as-we-know-it/</guid>
      <description>GNU and Richard Stallman was a real catalyst for the open source movement and it&amp;rsquo;s crown jewel; the Linux kernel. Not only did Mr Torvalds early Linux releases have near 100% GNU &amp;ldquo;user-land&amp;rdquo;, he also decided to use release it under the GNU Public License; GPL. GNU and Stallman is forever linked with the birth and popularization of open source, and innovated both technically and legally by turning copyright laws on it&amp;rsquo;s head with the copy-left licenses.</description>
    </item>
    <item>
      <title>Why F# needs Mono (and really should be a JVM language)</title>
      <link>https://martintrojer.github.io/post/2011-11-03-why-f-needs-mono-and-really-should-be-a-jvm-language/</link>
      <pubDate>Thu, 03 Nov 2011 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2011-11-03-why-f-needs-mono-and-really-should-be-a-jvm-language/</guid>
      <description>When people think about .NET development, they think of C#. Sure there are other languages (VB, ASP.NET etc) but .NET and C# are very tightly linked (just drop an .NET assembly in reflector for technical proof). If you&amp;rsquo;re writing a new Windows application (and it&amp;rsquo;s not a high performant game), chances are you are reading WPF books right now.&#xA;One of the promises of .NET when it was released was &amp;ldquo;the great language independent&amp;rdquo; runtime, making all these languages interoperate in joyful blizz.</description>
    </item>
    <item>
      <title>Scheming in F#</title>
      <link>https://martintrojer.github.io/post/2011-11-02-scheming-in-f/</link>
      <pubDate>Wed, 02 Nov 2011 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2011-11-02-scheming-in-f/</guid>
      <description>Given the fact that I worship at the SICP altar, it should come as no surprise that I follow the recipe outlined in chapter 4 of said book; implementing a Scheme interpreter in every language I am trying to learn. Over the years it has turned out to be a very useful exercise, since the problem is just &amp;ldquo;big enough&amp;rdquo; for to force me to drill into what the language have to offer.</description>
    </item>
    <item>
      <title>Symbolic Execution</title>
      <link>https://martintrojer.github.io/post/2011-11-02-symbolic-execution/</link>
      <pubDate>Wed, 02 Nov 2011 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2011-11-02-symbolic-execution/</guid>
      <description>A while back, I had the opportunity to collaborate with my colleague, Philippe Gabriel, on a research project focused on automating defect finding and enhancing overall test coverage. Our primary concern at the time was null pointer dereferences, which had the potential to cause system-wide crashes. In our quest, we explored various strategies and tools, both free and commercial. However, what truly captured our interest was a fascinating area of research called &amp;ldquo;Symbolic execution.</description>
    </item>
    <item>
      <title>What is software?</title>
      <link>https://martintrojer.github.io/post/2011-10-30-what-is-software/</link>
      <pubDate>Sun, 30 Oct 2011 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2011-10-30-what-is-software/</guid>
      <description>Having gained experience through numerous software projects and collaborations with diverse individuals, I&amp;rsquo;ve observed a recurring issue: a lack of understanding regarding the nature and process of software development. Surprisingly, even among developers, there persists a belief that seniority alone enables one to design and plan a problem, leaving less experienced developers to implement it. Some individuals still equate software development to assembly line production in the automotive industry.&#xA;In chapter 1 of &amp;ldquo;Structure and Interpretation of Computer Programs&amp;rdquo; SICP, Abelsson and Sussman describe a concept they call the &amp;ldquo;sorcerer&amp;rsquo;s spirit&amp;rdquo;</description>
    </item>
    <item>
      <title>Welcome and some guiding words...</title>
      <link>https://martintrojer.github.io/post/2011-10-29-welcome-and-some-guiding-words/</link>
      <pubDate>Sat, 29 Oct 2011 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2011-10-29-welcome-and-some-guiding-words/</guid>
      <description>Let&amp;rsquo;s begin with an inspiring quote from my favorite book on computer programming, &amp;ldquo;Structure and Interpretations of Computer Programs&amp;rdquo; (SICP) by Abelson and Sussman.&#xA;Underlying our approach to this subject (computer programming) is our conviction that “computer science” is not a science and that its significance has little to do with computers. The computer revolution is a revolution in the way we think and in the way we express what we think.</description>
    </item>
  </channel>
</rss>
