<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Valgrind on Martin Trojer</title>
    <link>https://martintrojer.github.io/tags/valgrind/</link>
    <description>Recent content in Valgrind on Martin Trojer</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 10 Nov 2011 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://martintrojer.github.io/tags/valgrind/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Applied Symbolic Execution with KLEE/LLVM</title>
      <link>https://martintrojer.github.io/post/2011-11-10-applied-symbolic-execution-with-kleellvm/</link>
      <pubDate>Thu, 10 Nov 2011 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2011-11-10-applied-symbolic-execution-with-kleellvm/</guid>
      <description>&lt;p&gt;This article serves as a follow-up to my previous post on symbolic execution, which can be found &lt;a href=&#34;https://martintrojer.github.io/post/2011-11-02-symbolic-execution/&#34;&gt;here&lt;/a&gt;. In this article, we will delve deeper into the details of KLEE and LLVM, discussing a potential practical application for a symbolic executor. We will also address some limitations and drawbacks associated with this approach.&lt;/p&gt;&#xA;&lt;p&gt;If you&amp;rsquo;re interested in the changes we made for KLEE and LLVM, you can find them on &lt;a href=&#34;https://github.com/martintrojer/symbolic-execution&#34;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;p&gt;One limitation of symbolic execution, as well as dynamic code analysis in general, is that the code under analysis needs to be buildable and linkable. Consequently, it is more challenging to analyze subsystems or code snippets compared to using a &lt;a href=&#34;http://en.wikipedia.org/wiki/Lint_(software)&#34;&gt;lint tool&lt;/a&gt;. Another complication arises from the fact that the symbolic executor&amp;rsquo;s virtual machine must also comprehend and model the system calls used by the code. This makes the tool OS-dependent, as it requires emulating all calls that &amp;ldquo;escape&amp;rdquo; the executor. Cadar, Dunbar, and Engler explain how this can be achieved for Linux by analyzing GNU coreutils in [1].&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
