<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>.Net on Martin Trojer</title>
    <link>https://martintrojer.github.io/tags/.net/</link>
    <description>Recent content in .Net on Martin Trojer</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 08 Nov 2014 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://martintrojer.github.io/tags/.net/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>F#&#39;s strongest year yet</title>
      <link>https://martintrojer.github.io/post/2014-11-08-fs-strongest-year-yet/</link>
      <pubDate>Sat, 08 Nov 2014 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2014-11-08-fs-strongest-year-yet/</guid>
      <description>&lt;p&gt;Tradition demands that I write down some subjective thoughts on how my old friend F# is doing. So here we go again (for the 4th year running).&lt;/p&gt;&#xA;&lt;p&gt;All I can really say is this: wow, what a year.&lt;/p&gt;</description>
    </item>
    <item>
      <title>This year in F#</title>
      <link>https://martintrojer.github.io/post/2013-10-29-this-year-in-f/</link>
      <pubDate>Tue, 29 Oct 2013 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2013-10-29-this-year-in-f/</guid>
      <description>&lt;p&gt;For the third year running, here&amp;rsquo;s my annual (and extremely subjective) review of the state of the F# language, its community and other loosely connected things. How would I sum up the noises coming from F# the last year? Pretty darn awesome. A lot of what&amp;rsquo;s been happening was on my wish-list outlined in &lt;a href=&#34;https://martintrojer.github.io/post/2012-10-24-the-future-of-net-lies-in-mono-the-future-of-f-lies-in-monodevelop/&#34;&gt;last year&amp;rsquo;s post&lt;/a&gt;. What are the highlights?&lt;/p&gt;</description>
    </item>
    <item>
      <title>Embedding a new runtime into your legacy C/C&#43;&#43; app</title>
      <link>https://martintrojer.github.io/post/2013-01-27-embedding-a-new-runtime-into-your-legacy-cc-app/</link>
      <pubDate>Sun, 27 Jan 2013 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2013-01-27-embedding-a-new-runtime-into-your-legacy-cc-app/</guid>
      <description>&lt;p&gt;Let&amp;rsquo;s say you have a big legacy C++ app. Then you&amp;rsquo;re undoubtedly covered by &lt;a href=&#34;http://en.wikipedia.org/wiki/Greenspun&#39;s_tenth_rule&#34;&gt;Greenspun&amp;rsquo;s tenth rule&lt;/a&gt;. Let&amp;rsquo;s also say that your home-grown, buggy, and slow DSL/scripting language has been pushed to its limit and cannot be tweaked any further. What do you do? How can you replace it?&lt;/p&gt;&#xA;&lt;p&gt;As you might expect, this is quite a common problem, and embedding scripting languages into a big C/C++ monolith is popular. There are famous examples from gaming where &lt;a href=&#34;http://en.wikipedia.org/wiki/Game_Oriented_Assembly_Lisp&#34;&gt;Lisps&lt;/a&gt; and &lt;a href=&#34;http://www.wowwiki.com/Lua&#34;&gt;Lua&lt;/a&gt; are widely used.&lt;/p&gt;</description>
    </item>
    <item>
      <title>The future of .NET lies in Mono. The future of F# lies in MonoDevelop.</title>
      <link>https://martintrojer.github.io/post/2012-10-24-the-future-of-net-lies-in-mono-the-future-of-f-lies-in-monodevelop/</link>
      <pubDate>Wed, 24 Oct 2012 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2012-10-24-the-future-of-net-lies-in-mono-the-future-of-f-lies-in-monodevelop/</guid>
      <description>&lt;p&gt;It&amp;rsquo;s been a year since &lt;a href=&#34;https://martintrojer.github.io/post/2011-11-03-why-f-needs-mono-and-really-should-be-a-jvm-language/&#34;&gt;I last wrote about F# and Mono&lt;/a&gt; - what&amp;rsquo;s happened since then?&lt;/p&gt;&#xA;&lt;p&gt;F# 3.0 has recently been released, bundled with the new &lt;a href=&#34;http://www.theregister.co.uk/2012/08/28/visual_studio_2012_review/&#34;&gt;all-grey&lt;/a&gt;, &lt;a href=&#34;http://blogs.msdn.com/b/visualstudio/archive/2012/06/05/a-design-with-all-caps.aspx&#34;&gt;ALL-CAPS&lt;/a&gt; Visual Studio 2012. The biggest new feature is &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/hh156509.aspx&#34;&gt;type providers&lt;/a&gt;, bringing some of the benefits of dynamic languages into the type-safe world. Innovations like type providers deserve more industry attention. I really hope these ideas will spread and hopefully languages like Scala will pick them up so more developers (including me) can enjoy the benefits.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Some thoughts on Clojure performance</title>
      <link>https://martintrojer.github.io/post/2012-02-18-some-thoughts-on-clojure-performance/</link>
      <pubDate>Sat, 18 Feb 2012 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2012-02-18-some-thoughts-on-clojure-performance/</guid>
      <description>&lt;p&gt;&lt;em&gt;Edit&lt;/em&gt;: This post recently re-surfaced on hacker news and caused a bit of a stir, mainly because of a slightly sensational/misleading title (was &amp;ldquo;Why is Clojure so slow?&amp;rdquo;). I wrote this before &lt;a href=&#34;http://www.youtube.com/watch?v=I5iNUtrYQSM&#34;&gt;Rich Hickey&amp;rsquo;s Clojure/Conj 2011 keynote&lt;/a&gt; was published, in which he talks about most of my concerns (and outlines possible solutions).&lt;/p&gt;&#xA;&lt;p&gt;Clojure is great in many ways, but one thing it can&amp;rsquo;t be accused of is being particularly fast. What I mean by fast here is the speed at which Clojure programs execute. This is a well-known issue in the Clojure community and has been discussed on the &lt;a href=&#34;http://groups.google.com/group/clojure&#34;&gt;mailing list&lt;/a&gt; and &lt;a href=&#34;http://stackoverflow.com/questions/2531616/why-is-the-clojure-hello-world-program-so-slow-compared-to-java-and-python&#34;&gt;Stack Overflow&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Asynchronous workflows in Clojure</title>
      <link>https://martintrojer.github.io/post/2011-12-22-asynchronous-workflows-in-clojure/</link>
      <pubDate>Thu, 22 Dec 2011 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2011-12-22-asynchronous-workflows-in-clojure/</guid>
      <description>&lt;p&gt;Asynchronous workflows is a very powerful feature of F#, and recently I wanted to explore the state of the JVM and in particular Clojure when it comes to replicate the functionality. In this post I&amp;rsquo;ll share some of my findings and I&amp;rsquo;ll include some background material to explain the problems.&lt;/p&gt;&#xA;&lt;p&gt;Let&amp;rsquo;s start with an example of a webclient using &amp;ldquo;async&amp;rdquo; in F#.&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-fsharp&#34; data-lang=&#34;fsharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; download url &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; async &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; request &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; HttpWebRequest.Create&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;Uri&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;url&lt;span style=&#34;color:#f92672&#34;&gt;))&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;let!&lt;/span&gt; response &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; request&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;AsyncGetResponse()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; stream &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; response&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;GetResponseStream()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;let!&lt;/span&gt; res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; asyncReadToEnd stream&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; res&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The magic here is that you can write continuation-style code in a sequential manner. This combines the scalability of asynchronous programs with the readability of sequential code. So, what lessons can we learn from this code and how would we do this with the JVM and Clojure? First of all, this is not the same as using futures over blocking calls;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Tail Calls in F#, Clojure and Scala</title>
      <link>https://martintrojer.github.io/post/2011-11-20-tail-calls-in-f-clojure-and-scala/</link>
      <pubDate>Sun, 20 Nov 2011 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2011-11-20-tail-calls-in-f-clojure-and-scala/</guid>
      <description>&lt;p&gt;I recently looked into Tail Call Optimisation/Elimination (TCO) and the implications for 3 modern languages, namely F#, Clojure and Scala. In this post I share my findings. If you&amp;rsquo;re new to the subject or just looking into some of these languages I hope this post can be of some use to you. I will mix code snippets in the 3 languages freely (and without warning! :)&lt;/p&gt;&#xA;&lt;p&gt;TCO is a well documented topic in books and articles about functional programming, and the TCO in .NET and the lack thereof in the JVM has been debated &amp;ldquo;to death&amp;rdquo; on various programmers&amp;rsquo; boards. I don&amp;rsquo;t intend to add any fuel to the fire here, rather some background and practical implications.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Why F# needs Mono (and really should be a JVM language)</title>
      <link>https://martintrojer.github.io/post/2011-11-03-why-f-needs-mono-and-really-should-be-a-jvm-language/</link>
      <pubDate>Thu, 03 Nov 2011 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2011-11-03-why-f-needs-mono-and-really-should-be-a-jvm-language/</guid>
      <description>&lt;p&gt;When people think about .NET development, they think of C#. Sure there are other languages (VB, ASP.NET etc) but .NET and C# are very tightly linked (just drop an .NET assembly in &lt;a href=&#34;http://www.reflector.net/&#34;&gt;reflector&lt;/a&gt; for technical proof). If you&amp;rsquo;re writing a new Windows application (and it&amp;rsquo;s not a high performant game), chances are you are reading &lt;a href=&#34;http://en.wikipedia.org/wiki/Windows_Presentation_Foundation&#34;&gt;WPF&lt;/a&gt; books right now.&lt;/p&gt;&#xA;&lt;p&gt;One of the promises of .NET when it was released was &amp;ldquo;the great language independent&amp;rdquo; runtime, making all these languages interoperate in joyful bliss. Technically this still holds, but in practice it&amp;rsquo;s all about C#.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
