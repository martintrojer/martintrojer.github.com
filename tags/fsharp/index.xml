<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>fsharp on Martin Trojer</title>
    <link>https://martintrojer.github.io/tags/fsharp/</link>
    <description>Recent content in fsharp on Martin Trojer</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 08 Nov 2014 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://martintrojer.github.io/tags/fsharp/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>F#&#39;s strongest year yet</title>
      <link>https://martintrojer.github.io/post/2014-11-08-fs-strongest-year-yet/</link>
      <pubDate>Sat, 08 Nov 2014 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2014-11-08-fs-strongest-year-yet/</guid>
      <description>&lt;p&gt;Tradition demands that I write down some subjective thoughts on how my old friend F# is doing. So here we go again (for the 4th year running).&lt;/p&gt;&#xA;&lt;p&gt;All I can really say is this; wow, what a year.&lt;/p&gt;</description>
    </item>
    <item>
      <title>This year in F#</title>
      <link>https://martintrojer.github.io/post/2013-10-29-this-year-in-f/</link>
      <pubDate>Tue, 29 Oct 2013 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2013-10-29-this-year-in-f/</guid>
      <description>&lt;p&gt;For the third year running, here&amp;rsquo;s my annual (and extremely subjective) review of the state of the F# language, its community and other loosely connected things. How would I sum up the noises coming from F# the last year? Pretty darn awesome. Alot of what&amp;rsquo;s been happening was on my wish-list outlined in [last year&amp;rsquo;s post](https://martintrojer.github.io/post/2012-10-24-the-future-of-net-lies-in-mono-the-future-of-f-lies-in-monodevelop/. What are the highlights?&lt;/p&gt;</description>
    </item>
    <item>
      <title>Comparing FP REPL Sessions</title>
      <link>https://martintrojer.github.io/post/2013-06-04-comparing-fp-repl-sessions/</link>
      <pubDate>Tue, 04 Jun 2013 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2013-06-04-comparing-fp-repl-sessions/</guid>
      <description>Functional programming is great; higher-order functions, closures, immutable data-structures, lazy sequences etc.&#xA;Most languages comes with a REPL (or &amp;lsquo;interactive&amp;rsquo; prompt), where you can play with these features at your leisure. Dynamically typed languages are a bit more convenient in the REPL, but not by as much as you might think. Also, F# type providers closes the gap even further.&#xA;Here&amp;rsquo;s a typical, hit-a-JSON-endpoint-and-look-at-the-data session in Clojure;&#xA;$ lein repl user=&amp;gt; (def res (slurp &amp;#34;http://www.</description>
    </item>
    <item>
      <title>Scala and me</title>
      <link>https://martintrojer.github.io/post/2013-06-01-scala-and-me/</link>
      <pubDate>Sat, 01 Jun 2013 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2013-06-01-scala-and-me/</guid>
      <description>This epic journey (yeah right) began at Uni with discovering the mighty SICP, still the best book on programming I&amp;rsquo;ve read (and let&amp;rsquo;s face it, the best I will ever read). After that profound experience I kept an eye on the Lisp/FP world and wrote some toys in Scheme, ELisp, OCaml every now and then. One thing that dawned on me was that none of these languages had much practical use, they weren&amp;rsquo;t very applicable to real-world software problems.</description>
    </item>
    <item>
      <title>Embedding a new runtime into your legacy C/C&#43;&#43; app</title>
      <link>https://martintrojer.github.io/post/2013-01-27-embedding-a-new-runtime-into-your-legacy-cc-app/</link>
      <pubDate>Sun, 27 Jan 2013 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2013-01-27-embedding-a-new-runtime-into-your-legacy-cc-app/</guid>
      <description>Let&amp;rsquo;s say you have a big / legacy C++ app, then you&amp;rsquo;re undoubtedly covered by Greenspun&amp;rsquo;s tenth rule. Let&amp;rsquo;s also say that your home-grown, buggy and slow DSL / scripting language has been pushed to the limit and can not be tweaked any further. What do you do, how can you replace it?&#xA;As you might expect, this is quite a common problem, and embedding scripting languages into a big C/C++ monolith is popular.</description>
    </item>
    <item>
      <title>The future of .NET lies in Mono. The future of F# lies in MonoDevelop.</title>
      <link>https://martintrojer.github.io/post/2012-10-24-the-future-of-net-lies-in-mono-the-future-of-f-lies-in-monodevelop/</link>
      <pubDate>Wed, 24 Oct 2012 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2012-10-24-the-future-of-net-lies-in-mono-the-future-of-f-lies-in-monodevelop/</guid>
      <description>It&amp;rsquo;s been a year since I last wrote about F# and Mono - what&amp;rsquo;s happened since then?&#xA;F# 3.0 has recently been released, bundled in with the new all-grey, ALL-CAPS Visual Studio 2012. The biggest new feature is type providers, bringing some of the benefits of dynamic languages into type safe world. Innovations like type providers deserve more industry attention. I really hope these ideas will spread and hopefully languages like Scala will pick them up pretty soon so more developers (including me) can enjoy the benefits.</description>
    </item>
    <item>
      <title>Some thoughts on Clojure performance</title>
      <link>https://martintrojer.github.io/post/2012-02-18-some-thoughts-on-clojure-performance/</link>
      <pubDate>Sat, 18 Feb 2012 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2012-02-18-some-thoughts-on-clojure-performance/</guid>
      <description>Edit: This post recently re-surfaced on hacker news and caused a bit of a stir, mainly because of a slightly sensational/misleading title (was &amp;ldquo;Why is Clojure so slow?&amp;rdquo;). I wrote this before Rich Hickey&amp;rsquo;s Clojure/Conj 2011 keynote was published, in which he talks about most of my concerns (and outlines possible solutions).&#xA;Clojure is great in many ways, but one thing it can&amp;rsquo;t be accused of is being particularly fast. What I mean by fast here is the speed in which Clojure programs execute.</description>
    </item>
    <item>
      <title>Scheme as an external DSL in Clojure</title>
      <link>https://martintrojer.github.io/post/2012-01-28-scheme-as-an-external-dsl-in-clojure/</link>
      <pubDate>Sat, 28 Jan 2012 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2012-01-28-scheme-as-an-external-dsl-in-clojure/</guid>
      <description>This is a follow-up post to my previous &amp;ldquo;Scheme in Clojure&amp;rdquo; post.&#xA;This time we implement a Scheme interpreter as an external DSL. This means that we consider the DSL as completely foreign to the host language, so we need to write our own parser (or reader as it&amp;rsquo;s called in Clojure) and interpreter. I have to admit that this is a bit of an academic exercise because the internal DSL version I wrote about previously is both smaller (less code) and faster (as fast as any other Clojure code).</description>
    </item>
    <item>
      <title>Asynchronous workflows in Clojure</title>
      <link>https://martintrojer.github.io/post/2011-12-22-asynchronous-workflows-in-clojure/</link>
      <pubDate>Thu, 22 Dec 2011 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2011-12-22-asynchronous-workflows-in-clojure/</guid>
      <description>Asynchronous workflows is a very powerful feature of F#, and recently I wanted to explore the state of the JVM and in particular Clojure when it comes to replicate the functionality. In this post I&amp;rsquo;ll share some of my findings and I&amp;rsquo;ll include some background material to explain the problems.&#xA;Let&amp;rsquo;s start with an example of a webclient using &amp;ldquo;async&amp;rdquo; in F#.&#xA;let download url = async { let request = HttpWebRequest.</description>
    </item>
    <item>
      <title>Parsing with Matches and Banana Clips</title>
      <link>https://martintrojer.github.io/post/2011-12-03-parsing-with-matches-and-banana-clips/</link>
      <pubDate>Sat, 03 Dec 2011 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2011-12-03-parsing-with-matches-and-banana-clips/</guid>
      <description>I find myself working with DSLs quite a bit, and thus I write a few parsers. Some languages are better than others for parsers and pattern matching is a technique that makes writing parsers a true joy. I will not go over the basics of pattern matching here, rather show how F#&amp;rsquo;s active patterns can be used to take pattern matching to the next level.&#xA;The traditional steps of a &amp;ldquo;parser&amp;rdquo; are roughly lexical analysis (tokenizer), syntactic analysis (parser) and then evaluator (interpreter).</description>
    </item>
    <item>
      <title>Tail Calls in F#, Clojure and Scala</title>
      <link>https://martintrojer.github.io/post/2011-11-20-tail-calls-in-f-clojure-and-scala/</link>
      <pubDate>Sun, 20 Nov 2011 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2011-11-20-tail-calls-in-f-clojure-and-scala/</guid>
      <description>I recently looked into Tail Call Optimisation/Elimination (TCO) and the implications for 3 modern languages, namely F#, Clojure and Scala. In this post I share my my findings. If you&amp;rsquo;re new to the subject or just looking into some of these languages I hope this post can be of some use to you. I will mix code snippets in the 3 languages freely (and without warning! :)&#xA;TCO is a well documented topic in books and articles about functional programming and the TCO in .</description>
    </item>
    <item>
      <title>Why F# needs Mono (and really should be a JVM language)</title>
      <link>https://martintrojer.github.io/post/2011-11-03-why-f-needs-mono-and-really-should-be-a-jvm-language/</link>
      <pubDate>Thu, 03 Nov 2011 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2011-11-03-why-f-needs-mono-and-really-should-be-a-jvm-language/</guid>
      <description>When people think about .NET development, they think of C#. Sure there are other languages (VB, ASP.NET etc) but .NET and C# are very tightly linked (just drop an .NET assembly in reflector for technical proof). If you&amp;rsquo;re writing a new Windows application (and it&amp;rsquo;s not a high performant game), chances are you are reading WPF books right now.&#xA;One of the promises of .NET when it was released was &amp;ldquo;the great language independent&amp;rdquo; runtime, making all these languages interoperate in joyful blizz.</description>
    </item>
    <item>
      <title>Scheming in F#</title>
      <link>https://martintrojer.github.io/post/2011-11-02-scheming-in-f/</link>
      <pubDate>Wed, 02 Nov 2011 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2011-11-02-scheming-in-f/</guid>
      <description>Given the fact that I worship at the SICP altar, it should come as no surprise that I follow the recipe outlined in chapter 4 of said book; implementing a Scheme interpreter in every language I am trying to learn. Over the years it has turned out to be a very useful exercise, since the problem is just &amp;ldquo;big enough&amp;rdquo; for to force me to drill into what the language have to offer.</description>
    </item>
  </channel>
</rss>
