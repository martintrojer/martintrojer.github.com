<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Fsharp on Martin Trojer</title>
    <link>https://martintrojer.github.io/tags/fsharp/</link>
    <description>Recent content in Fsharp on Martin Trojer</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 08 Nov 2014 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://martintrojer.github.io/tags/fsharp/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>F#&#39;s strongest year yet</title>
      <link>https://martintrojer.github.io/post/2014-11-08-fs-strongest-year-yet/</link>
      <pubDate>Sat, 08 Nov 2014 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2014-11-08-fs-strongest-year-yet/</guid>
      <description>&lt;p&gt;Tradition demands that I write down some subjective thoughts on how my old friend F# is doing. So here we go again (for the 4th year running).&lt;/p&gt;&#xA;&lt;p&gt;All I can really say is this: wow, what a year.&lt;/p&gt;</description>
    </item>
    <item>
      <title>This year in F#</title>
      <link>https://martintrojer.github.io/post/2013-10-29-this-year-in-f/</link>
      <pubDate>Tue, 29 Oct 2013 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2013-10-29-this-year-in-f/</guid>
      <description>&lt;p&gt;For the third year running, here&amp;rsquo;s my annual (and extremely subjective) review of the state of the F# language, its community and other loosely connected things. How would I sum up the noises coming from F# the last year? Pretty darn awesome. A lot of what&amp;rsquo;s been happening was on my wish-list outlined in &lt;a href=&#34;https://martintrojer.github.io/post/2012-10-24-the-future-of-net-lies-in-mono-the-future-of-f-lies-in-monodevelop/&#34;&gt;last year&amp;rsquo;s post&lt;/a&gt;. What are the highlights?&lt;/p&gt;</description>
    </item>
    <item>
      <title>Comparing FP REPL Sessions</title>
      <link>https://martintrojer.github.io/post/2013-06-04-comparing-fp-repl-sessions/</link>
      <pubDate>Tue, 04 Jun 2013 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2013-06-04-comparing-fp-repl-sessions/</guid>
      <description>&lt;p&gt;Functional programming is great; higher-order functions, closures, immutable data-structures, lazy sequences etc.&lt;/p&gt;&#xA;&lt;p&gt;Most languages comes with a REPL (or &amp;lsquo;interactive&amp;rsquo; prompt), where you can play with these features at your leisure. Dynamically typed languages are a bit more convenient in the REPL, but not by as much as you might think. Also, F# type providers closes the gap even further.&lt;/p&gt;&#xA;&lt;p&gt;Here&amp;rsquo;s a typical, hit-a-JSON-endpoint-and-look-at-the-data session in Clojure;&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-clojure&#34; data-lang=&#34;clojure&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ lein repl&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;user=&amp;gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;def &lt;/span&gt;res (slurp &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;http://www.bbc.co.uk/tv/programmes/genres/drama/scifiandfantasy/schedules/upcoming.json&amp;#34;&lt;/span&gt;))&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;user=&amp;gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;require&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;clojure.data.json&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;clojure.walk&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;user=&amp;gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;def &lt;/span&gt;json (&lt;span style=&#34;color:#a6e22e&#34;&gt;-&amp;gt;&amp;gt;&lt;/span&gt; res clojure.data.json/read-str&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                      clojure.walk/keywordize-keys))&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;user=&amp;gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;-&amp;gt;&amp;gt;&lt;/span&gt; json &lt;span style=&#34;color:#e6db74&#34;&gt;:broadcasts&lt;/span&gt; (filter &lt;span style=&#34;color:#f92672&#34;&gt;#&lt;/span&gt;(&amp;gt;= (&lt;span style=&#34;color:#e6db74&#34;&gt;:duration&lt;/span&gt; %) &lt;span style=&#34;color:#ae81ff&#34;&gt;6300&lt;/span&gt;))&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            (map &lt;span style=&#34;color:#e6db74&#34;&gt;:programme&lt;/span&gt;) (map (&lt;span style=&#34;color:#a6e22e&#34;&gt;juxt&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;:title&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;:pid&lt;/span&gt;)))&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;([&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Lady in the Water&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;b00l5wdn&amp;#34;&lt;/span&gt;] [&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Lady in the Water&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;b00l5wdn&amp;#34;&lt;/span&gt;] [&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Lady in the Water&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;b00l5wdn&amp;#34;&lt;/span&gt;] [&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Lady in the Water&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;b00l5wdn&amp;#34;&lt;/span&gt;])&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Nice, clean and very powerful, virtually zero ceremony. Doing the same in Scala, is just a little bit more awkward;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Scala and me</title>
      <link>https://martintrojer.github.io/post/2013-06-01-scala-and-me/</link>
      <pubDate>Sat, 01 Jun 2013 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2013-06-01-scala-and-me/</guid>
      <description>&lt;figure class=&#34;floatright&#34;&gt;&lt;img src=&#34;https://martintrojer.github.io/assets/images/scalame/martin.png&#34;&gt;&#xA;&lt;/figure&gt;&#xA;&#xA;&lt;p&gt;This epic journey (yeah right) began at university with discovering the mighty &lt;a href=&#34;http://mitpress.mit.edu/sicp/&#34;&gt;SICP&lt;/a&gt;, still the best book on programming I&amp;rsquo;ve read (and let&amp;rsquo;s face it, the best I will ever read). After that profound experience, I kept an eye on the Lisp/FP world and wrote some toys in &lt;a href=&#34;http://plt-scheme.org/&#34;&gt;Scheme&lt;/a&gt;, &lt;a href=&#34;http://en.wikipedia.org/wiki/Emacs_Lisp&#34;&gt;ELisp&lt;/a&gt;, and &lt;a href=&#34;http://ocaml.org/&#34;&gt;OCaml&lt;/a&gt; every now and then. One thing that dawned on me was that none of these languages had much practical use; they weren&amp;rsquo;t very applicable to real-world software problems. While very clever and mind-expanding, they seemed mainly an academic exercise. There were zero jobs out there using these languages. Heck, hardly any of my peers had heard of or cared about them.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Embedding a new runtime into your legacy C/C&#43;&#43; app</title>
      <link>https://martintrojer.github.io/post/2013-01-27-embedding-a-new-runtime-into-your-legacy-cc-app/</link>
      <pubDate>Sun, 27 Jan 2013 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2013-01-27-embedding-a-new-runtime-into-your-legacy-cc-app/</guid>
      <description>&lt;p&gt;Let&amp;rsquo;s say you have a big legacy C++ app. Then you&amp;rsquo;re undoubtedly covered by &lt;a href=&#34;http://en.wikipedia.org/wiki/Greenspun&#39;s_tenth_rule&#34;&gt;Greenspun&amp;rsquo;s tenth rule&lt;/a&gt;. Let&amp;rsquo;s also say that your home-grown, buggy, and slow DSL/scripting language has been pushed to its limit and cannot be tweaked any further. What do you do? How can you replace it?&lt;/p&gt;&#xA;&lt;p&gt;As you might expect, this is quite a common problem, and embedding scripting languages into a big C/C++ monolith is popular. There are famous examples from gaming where &lt;a href=&#34;http://en.wikipedia.org/wiki/Game_Oriented_Assembly_Lisp&#34;&gt;Lisps&lt;/a&gt; and &lt;a href=&#34;http://www.wowwiki.com/Lua&#34;&gt;Lua&lt;/a&gt; are widely used.&lt;/p&gt;</description>
    </item>
    <item>
      <title>The future of .NET lies in Mono. The future of F# lies in MonoDevelop.</title>
      <link>https://martintrojer.github.io/post/2012-10-24-the-future-of-net-lies-in-mono-the-future-of-f-lies-in-monodevelop/</link>
      <pubDate>Wed, 24 Oct 2012 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2012-10-24-the-future-of-net-lies-in-mono-the-future-of-f-lies-in-monodevelop/</guid>
      <description>&lt;p&gt;It&amp;rsquo;s been a year since &lt;a href=&#34;https://martintrojer.github.io/post/2011-11-03-why-f-needs-mono-and-really-should-be-a-jvm-language/&#34;&gt;I last wrote about F# and Mono&lt;/a&gt; - what&amp;rsquo;s happened since then?&lt;/p&gt;&#xA;&lt;p&gt;F# 3.0 has recently been released, bundled with the new &lt;a href=&#34;http://www.theregister.co.uk/2012/08/28/visual_studio_2012_review/&#34;&gt;all-grey&lt;/a&gt;, &lt;a href=&#34;http://blogs.msdn.com/b/visualstudio/archive/2012/06/05/a-design-with-all-caps.aspx&#34;&gt;ALL-CAPS&lt;/a&gt; Visual Studio 2012. The biggest new feature is &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/hh156509.aspx&#34;&gt;type providers&lt;/a&gt;, bringing some of the benefits of dynamic languages into the type-safe world. Innovations like type providers deserve more industry attention. I really hope these ideas will spread and hopefully languages like Scala will pick them up so more developers (including me) can enjoy the benefits.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Some thoughts on Clojure performance</title>
      <link>https://martintrojer.github.io/post/2012-02-18-some-thoughts-on-clojure-performance/</link>
      <pubDate>Sat, 18 Feb 2012 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2012-02-18-some-thoughts-on-clojure-performance/</guid>
      <description>&lt;p&gt;&lt;em&gt;Edit&lt;/em&gt;: This post recently re-surfaced on hacker news and caused a bit of a stir, mainly because of a slightly sensational/misleading title (was &amp;ldquo;Why is Clojure so slow?&amp;rdquo;). I wrote this before &lt;a href=&#34;http://www.youtube.com/watch?v=I5iNUtrYQSM&#34;&gt;Rich Hickey&amp;rsquo;s Clojure/Conj 2011 keynote&lt;/a&gt; was published, in which he talks about most of my concerns (and outlines possible solutions).&lt;/p&gt;&#xA;&lt;p&gt;Clojure is great in many ways, but one thing it can&amp;rsquo;t be accused of is being particularly fast. What I mean by fast here is the speed at which Clojure programs execute. This is a well-known issue in the Clojure community and has been discussed on the &lt;a href=&#34;http://groups.google.com/group/clojure&#34;&gt;mailing list&lt;/a&gt; and &lt;a href=&#34;http://stackoverflow.com/questions/2531616/why-is-the-clojure-hello-world-program-so-slow-compared-to-java-and-python&#34;&gt;Stack Overflow&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Scheme as an external DSL in Clojure</title>
      <link>https://martintrojer.github.io/post/2012-01-28-scheme-as-an-external-dsl-in-clojure/</link>
      <pubDate>Sat, 28 Jan 2012 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2012-01-28-scheme-as-an-external-dsl-in-clojure/</guid>
      <description>&lt;p&gt;This is a follow-up post to my previous &lt;a href=&#34;https://martintrojer.github.io/post/2011-11-29-scheme-as-an-embedded-dsl-in-clojure/&#34;&gt;&amp;ldquo;Scheme in Clojure&amp;rdquo; post&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;p&gt;This time we implement a Scheme interpreter as an external DSL. This means that we consider the DSL as completely foreign to the host language, so we need to write our own parser (or reader as it&amp;rsquo;s called in Clojure) and interpreter. I have to admit that this is a bit of an academic exercise because the internal DSL version I wrote about previously is both smaller (less code) and faster (as fast as any other Clojure code). However, this can serve as an example of how to write parsers in Clojure and it also highlights how elegant and succinct such a parser/interpreter can be. And of course, it&amp;rsquo;s pretty darn fun :-)&lt;/p&gt;</description>
    </item>
    <item>
      <title>Asynchronous workflows in Clojure</title>
      <link>https://martintrojer.github.io/post/2011-12-22-asynchronous-workflows-in-clojure/</link>
      <pubDate>Thu, 22 Dec 2011 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2011-12-22-asynchronous-workflows-in-clojure/</guid>
      <description>&lt;p&gt;Asynchronous workflows is a very powerful feature of F#, and recently I wanted to explore the state of the JVM and in particular Clojure when it comes to replicate the functionality. In this post I&amp;rsquo;ll share some of my findings and I&amp;rsquo;ll include some background material to explain the problems.&lt;/p&gt;&#xA;&lt;p&gt;Let&amp;rsquo;s start with an example of a webclient using &amp;ldquo;async&amp;rdquo; in F#.&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-fsharp&#34; data-lang=&#34;fsharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; download url &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; async &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; request &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; HttpWebRequest.Create&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;Uri&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;url&lt;span style=&#34;color:#f92672&#34;&gt;))&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;let!&lt;/span&gt; response &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; request&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;AsyncGetResponse()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; stream &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; response&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;GetResponseStream()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;let!&lt;/span&gt; res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; asyncReadToEnd stream&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; res&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The magic here is that you can write continuation-style code in a sequential manner. This combines the scalability of asynchronous programs with the readability of sequential code. So, what lessons can we learn from this code and how would we do this with the JVM and Clojure? First of all, this is not the same as using futures over blocking calls;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Parsing with Matches and Banana Clips</title>
      <link>https://martintrojer.github.io/post/2011-12-03-parsing-with-matches-and-banana-clips/</link>
      <pubDate>Sat, 03 Dec 2011 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2011-12-03-parsing-with-matches-and-banana-clips/</guid>
      <description>&lt;p&gt;I find myself working with DSLs quite a bit, and thus I write a few parsers. Some languages are better than others for parsers and pattern matching is a technique that makes writing parsers a true joy. I will not go over the &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/dd547125.aspx&#34;&gt;basics of pattern matching&lt;/a&gt; here, rather show how F#&amp;rsquo;s &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/dd233248.aspx&#34;&gt;active patterns&lt;/a&gt; can be used to take pattern matching to the next level.&lt;/p&gt;&#xA;&lt;p&gt;The traditional steps of a &amp;ldquo;parser&amp;rdquo; are roughly lexical analysis (tokenizer), syntactic analysis (parser) and then evaluator (interpreter). In this post we&amp;rsquo;ll focus on the parsing step of a simple DSL. A parser typically consume a list of tokens and produces an Abstract Syntax Tree (AST), ready to be passed on the evaluator/interpreter.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Tail Calls in F#, Clojure and Scala</title>
      <link>https://martintrojer.github.io/post/2011-11-20-tail-calls-in-f-clojure-and-scala/</link>
      <pubDate>Sun, 20 Nov 2011 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2011-11-20-tail-calls-in-f-clojure-and-scala/</guid>
      <description>&lt;p&gt;I recently looked into Tail Call Optimisation/Elimination (TCO) and the implications for 3 modern languages, namely F#, Clojure and Scala. In this post I share my findings. If you&amp;rsquo;re new to the subject or just looking into some of these languages I hope this post can be of some use to you. I will mix code snippets in the 3 languages freely (and without warning! :)&lt;/p&gt;&#xA;&lt;p&gt;TCO is a well documented topic in books and articles about functional programming, and the TCO in .NET and the lack thereof in the JVM has been debated &amp;ldquo;to death&amp;rdquo; on various programmers&amp;rsquo; boards. I don&amp;rsquo;t intend to add any fuel to the fire here, rather some background and practical implications.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Why F# needs Mono (and really should be a JVM language)</title>
      <link>https://martintrojer.github.io/post/2011-11-03-why-f-needs-mono-and-really-should-be-a-jvm-language/</link>
      <pubDate>Thu, 03 Nov 2011 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2011-11-03-why-f-needs-mono-and-really-should-be-a-jvm-language/</guid>
      <description>&lt;p&gt;When people think about .NET development, they think of C#. Sure there are other languages (VB, ASP.NET etc) but .NET and C# are very tightly linked (just drop an .NET assembly in &lt;a href=&#34;http://www.reflector.net/&#34;&gt;reflector&lt;/a&gt; for technical proof). If you&amp;rsquo;re writing a new Windows application (and it&amp;rsquo;s not a high performant game), chances are you are reading &lt;a href=&#34;http://en.wikipedia.org/wiki/Windows_Presentation_Foundation&#34;&gt;WPF&lt;/a&gt; books right now.&lt;/p&gt;&#xA;&lt;p&gt;One of the promises of .NET when it was released was &amp;ldquo;the great language independent&amp;rdquo; runtime, making all these languages interoperate in joyful bliss. Technically this still holds, but in practice it&amp;rsquo;s all about C#.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Scheming in F#</title>
      <link>https://martintrojer.github.io/post/2011-11-02-scheming-in-f/</link>
      <pubDate>Wed, 02 Nov 2011 00:00:00 +0000</pubDate>
      <guid>https://martintrojer.github.io/post/2011-11-02-scheming-in-f/</guid>
      <description>&lt;p&gt;Given the fact that I worship at the &lt;a href=&#34;https://web.mit.edu/6.001/6.037/sicp.pdf&#34;&gt;SICP&lt;/a&gt; altar, it should come as no surprise that I follow the recipe outlined in chapter 4 of said book; implementing a &lt;a href=&#34;http://en.wikipedia.org/wiki/Scheme_(programming_language)&#34;&gt;Scheme&lt;/a&gt; interpreter in every language I am trying to learn. Over the years it has turned out to be a very useful exercise, since the problem is just &amp;ldquo;big enough&amp;rdquo; to force me to drill into what the languages have to offer.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
