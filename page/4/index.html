<!DOCTYPE html>
<html lang="en-us">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<style type=text/css>body{font-family:monospace;}</style>
	<title>Martin Trojer</title>
	
	
	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="Martin Trojer">
</head>
<body>
	<header>
	===================<br>
	== Martin Trojer ==
	<div style="float: right;">Programming Blog</div><br>
	===================
	<p>
	<nav>
			<a href="/"><b>Start</b></a>.
			
			
			<a href="/about/"><b>About</b></a>.
			
			<a href="/categories/"><b>Categories</b></a>.
			
			<a href="/tags/"><b>Tags</b></a>.
			
	</nav>
	</p>
	
</header>

	
	<main>
		
		
			<article>
	<h1><a href="https://martintrojer.github.io/post/2013-03-16-flexible-multi-consumerproducer-pipelines/">Flexible multi consumer/producer pipelines</a></h1>
	<b><time>2013-03-16</time></b>
	
	<a href="/tags/clojure">clojure</a>
	
	<div>
		TL;DR Pipejine - a lightweight Clojure library for multi-threaded producer/consumer pipelines supporting arbitrary DAG topologies.
Recently a colleague and I faced a problem where we needed to optimize the total running time of a complicated calculation. This calculation involved several asynchronous steps getting data from other systems (like elasticsearch and other home-grown services) and a bit of number crunching and tallying up the results at the end. Here is and simplified example of the system.
		
			<a href="https://martintrojer.github.io/post/2013-03-16-flexible-multi-consumerproducer-pipelines/">Read more...</a>
		
	</div>
</article>

		
			<article>
	<h1><a href="https://martintrojer.github.io/post/2013-01-27-embedding-a-new-runtime-into-your-legacy-cc-app/">Embedding a new runtime into your legacy C/C&#43;&#43; app</a></h1>
	<b><time>2013-01-27</time></b>
	
	<a href="/tags/.net">.net</a>
	
	<a href="/tags/csharp">csharp</a>
	
	<a href="/tags/fsharp">fsharp</a>
	
	<a href="/tags/gnu">gnu</a>
	
	<a href="/tags/guile">guile</a>
	
	<a href="/tags/javascript">javascript</a>
	
	<a href="/tags/lisp">lisp</a>
	
	<a href="/tags/lua">lua</a>
	
	<a href="/tags/mono">mono</a>
	
	<div>
		Let&rsquo;s say you have a big / legacy C++ app, then you&rsquo;re undoubtedly covered by Greenspun&rsquo;s tenth rule. Let&rsquo;s also say that your home-grown, buggy and slow DSL / scripting language has been pushed to the limit and can not be tweaked any further. What do you do, how can you replace it?
As you might expect, this is quite a common problem, and embedding scripting languages into a big C/C++ monolith is popular.
		
			<a href="https://martintrojer.github.io/post/2013-01-27-embedding-a-new-runtime-into-your-legacy-cc-app/">Read more...</a>
		
	</div>
</article>

		
			<article>
	<h1><a href="https://martintrojer.github.io/post/2012-11-24-the-m-word/">The M Word</a></h1>
	<b><time>2012-11-24</time></b>
	
	<a href="/tags/clojure">clojure</a>
	
	<a href="/tags/monads">monads</a>
	
	<div>
		
		
			<a href="https://martintrojer.github.io/post/2012-11-24-the-m-word/">Read more...</a>
		
	</div>
</article>

		
			<article>
	<h1><a href="https://martintrojer.github.io/post/2012-10-24-the-future-of-net-lies-in-mono-the-future-of-f-lies-in-monodevelop/">The future of .NET lies in Mono. The future of F# lies in MonoDevelop.</a></h1>
	<b><time>2012-10-24</time></b>
	
	<a href="/tags/.net">.net</a>
	
	<a href="/tags/mono">mono</a>
	
	<a href="/tags/fsharp">fsharp</a>
	
	<div>
		It&rsquo;s been a year since I last wrote about F# and Mono - what&rsquo;s happened since then?
F# 3.0 has recently been released, bundled in with the new all-grey, ALL-CAPS Visual Studio 2012. The biggest new feature is type providers, bringing some of the benefits of dynamic languages into type safe world. Innovations like type providers deserve more industry attention. I really hope these ideas will spread and hopefully languages like Scala will pick them up pretty soon so more developers (including me) can enjoy the benefits.
		
			<a href="https://martintrojer.github.io/post/2012-10-24-the-future-of-net-lies-in-mono-the-future-of-f-lies-in-monodevelop/">Read more...</a>
		
	</div>
</article>

		
			<article>
	<h1><a href="https://martintrojer.github.io/post/2012-09-27-some-corelogic-graph-code/">Some core.logic graph code</a></h1>
	<b><time>2012-09-27</time></b>
	
	<a href="/tags/clojure">clojure</a>
	
	<a href="/tags/core.logic">core.logic</a>
	
	<div>
		
		
			<a href="https://martintrojer.github.io/post/2012-09-27-some-corelogic-graph-code/">Read more...</a>
		
	</div>
</article>

		
			<article>
	<h1><a href="https://martintrojer.github.io/post/2012-08-28-some-more-datalog/">Some more Datalog</a></h1>
	<b><time>2012-08-28</time></b>
	
	<a href="/tags/clojure">clojure</a>
	
	<a href="/tags/datalog">datalog</a>
	
	<a href="/tags/datomic">datomic</a>
	
	<div>
		I&rsquo;ve written about datalog and Datomic a bit recently. To conclude here&rsquo;s another post comparing execution speed with the contrib.datalog library, by Jeffrey Straszheim. Clojure1.4 ready source can be found here.
The example I&rsquo;m using in my benchmark is a simple join between two relations, in datomic/datalog it would look like this;
(q &#39;[:find ?first ?height :in $a $b :where [$a ?last ?first ?email] [$b ?email ?height]] [[&#34;Doe&#34; &#34;John&#34; &#34;jdoe@example.com&#34;] [&#34;Doe&#34; &#34;Jane&#34; &#34;jane@example.
		
			<a href="https://martintrojer.github.io/post/2012-08-28-some-more-datalog/">Read more...</a>
		
	</div>
</article>

		
			<article>
	<h1><a href="https://martintrojer.github.io/post/2012-08-12-ckanren-time/">cKanren time!</a></h1>
	<b><time>2012-08-12</time></b>
	
	<a href="/tags/clojure">clojure</a>
	
	<a href="/tags/core.logic">core.logic</a>
	
	<div>
		Mr David Nolen recently published core.logic 0.8.alpha2, with added cKanren (c for constraints) support. To celebrate this glorious event I&rsquo;m writing up some core.logic/cKanren stuff I&rsquo;ve been looking at recently.
Enter the Queens If you&rsquo;ve followed this blog, you&rsquo;ve perhaps seen my previous posts on solving N-Queens in core.logic (part1 and part2). How will this look and perform using the new shiny cKanren extensions in core.logic 0.8? Obviously there are many (new) ways to solve this problem, here&rsquo;s a core.
		
			<a href="https://martintrojer.github.io/post/2012-08-12-ckanren-time/">Read more...</a>
		
	</div>
</article>

		
			<article>
	<h1><a href="https://martintrojer.github.io/post/2012-07-23-untying-the-recursive-knot/">Untying the Recursive Knot</a></h1>
	<b><time>2012-07-23</time></b>
	
	<a href="/tags/clojure">clojure</a>
	
	<div>
		Here I present a couple of examples of the functional design pattern &ldquo;untying the recursive knot&rdquo;. I&rsquo;ve found this useful in a couple of occasions, for instance when breaking apart mutually recursive functions. Material inspired by Jon Harrop&rsquo;s excellent Visual F# to Technical Computing.
First, let&rsquo;s look at a simple factorial implementation using direct recursion;
(defn fact [n] (if (= n 0) 1 (* n (fact (dec n))))) We can break the direct recursive dependency by replacing the recursive calls with calls to a function argument;
		
			<a href="https://martintrojer.github.io/post/2012-07-23-untying-the-recursive-knot/">Read more...</a>
		
	</div>
</article>

		
			<article>
	<h1><a href="https://martintrojer.github.io/post/2012-07-17-replicating-datomicdatalog-queries-with-corelogic-take-2/">Replicating Datomic/Datalog queries with core.logic, take 2</a></h1>
	<b><time>2012-07-17</time></b>
	
	<a href="/tags/clojure">clojure</a>
	
	<a href="/tags/datomic">datomic</a>
	
	<a href="/tags/core.logic">core.logic</a>
	
	<div>
		This is a follow-up to my previous post on datalog-equivalent queries in core.logic.
Here I present an alternate way to do the unification and join inside core.logic (without having to use clojure.set/join). It uses the the relationships / facts API in core logic, described here. First let&rsquo;s consider this datomic query;
(q &#39;[:find ?first ?height :in [[?last ?first ?email]] [[?email ?height]]] [[&#34;Doe&#34; &#34;John&#34; &#34;jdoe@example.com&#34;] [&#34;Doe&#34; &#34;Jane&#34; &#34;jane@example.com&#34;]] [[&#34;jane@example.com&#34; 73] [&#34;jdoe@example.com&#34; 71]]) ;; #&lt;HashSet [[&#34;Jane&#34; 73], [&#34;John&#34; 71]]&gt; In core.
		
			<a href="https://martintrojer.github.io/post/2012-07-17-replicating-datomicdatalog-queries-with-corelogic-take-2/">Read more...</a>
		
	</div>
</article>

		
			<article>
	<h1><a href="https://martintrojer.github.io/post/2012-07-16-replicating-datomicdatalog-queries-with-corelogic/">Replicating Datomic/Datalog queries with core.logic</a></h1>
	<b><time>2012-07-16</time></b>
	
	<a href="/tags/clojure">clojure</a>
	
	<a href="/tags/core.logic">core.logic</a>
	
	<a href="/tags/datomic">datomic</a>
	
	<div>
		I&rsquo;ve been toying with Datomic recently, and I particularly like the power of it&rsquo;s query language (~Datalog). Mr Halloway showed a couple of months ago how the query engine is generic enough to be run on standard Clojure collections, gist here. Here is an example from that page of a simple join;
(q &#39;[:find ?first ?height :in [[?last ?first ?email]] [[?email ?height]]] [[&#34;Doe&#34; &#34;John&#34; &#34;jdoe@example.com&#34;] [&#34;Doe&#34; &#34;Jane&#34; &#34;jane@example.com&#34;]] [[&#34;jane@example.com&#34; 73] [&#34;jdoe@example.
		
			<a href="https://martintrojer.github.io/post/2012-07-16-replicating-datomicdatalog-queries-with-corelogic/">Read more...</a>
		
	</div>
</article>

		
		<div>

	<a href="/page/3/">Previous Page</a>

4 of 7

	<a href="/page/5/">Next Page</a>

</div>

	</main>

	<footer>
	<p>&copy; 2024 <a href="https://martintrojer.github.io/"><b>Martin Trojer</b></a>.
	<a href="https://github.com/martintrojer"><b>Github</b></a>.
	<a href="https://uk.linkedin.com/in/martintrojer"><b>LinkedIn</b></a>.
	</p>
</footer>

</body>
</html>
