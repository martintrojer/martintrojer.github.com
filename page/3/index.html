<!DOCTYPE html>
<html lang="en-us">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<style type=text/css>body{font-family:monospace;}</style>
	<title>Martin Trojer</title>
	
	
	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="Martin Trojer">
</head>
<body>
	<header>
	===================<br>
	== Martin Trojer ==
	<div style="float: right;">A programming blog</div><br>
	===================
	<p>
	<nav>
			<a href="/"><b>Start</b></a>.
			
			
			<a href="/about/"><b>About</b></a>.
			
			<a href="/categories/"><b>Categories</b></a>.
			
			<a href="/tags/"><b>Tags</b></a>.
			
	</nav>
	</p>
	
</header>

	
	<main>
		
		
			<article>
	<h1><a href="https://martintrojer.github.io/post/2013-09-07-retrofitting-the-reloaded-pattern-into-clojure-projects/">Retrofitting the Reloaded pattern into Clojure projects</a></h1>
	<b><time>2013-09-07</time></b>
	
	<a href="/tags/clojure">clojure</a>
	
	<div>
		Stuart Sierra has done a great job with clojure.tools.namespace and the reloaded leiningen template. If you haven&rsquo;t heard about this before please have a look at c.t.n readme and watch this presentation.
I&rsquo;ve have retrofitted this pattern into two rather big clojure projects (20k and 5k lines) with several modules and here are some of my findings.
Removing global state The first step is to find all resources that needs to be &ldquo;lifecycled&rdquo;.
		
			<a href="https://martintrojer.github.io/post/2013-09-07-retrofitting-the-reloaded-pattern-into-clojure-projects/">Read more...</a>
		
	</div>
</article>

		
			<article>
	<h1><a href="https://martintrojer.github.io/post/2013-07-17-non-tailrecursive-functions-in-coreasync/">Non tail-recursive functions in core.async go blocks</a></h1>
	<b><time>2013-07-17</time></b>
	
	<a href="/tags/clojure">clojure</a>
	
	<a href="/tags/core.async">core.async</a>
	
	<a href="/tags/go">go</a>
	
	<div>
		I&rsquo;ve been using various Go examples / tutorials to take a deeper look into core.async. The CSP pattern is a very interesting and powerful, it&rsquo;s good move for Clojure to &ldquo;throw in&rdquo; with Go and push this style of programming.
core.sync works at s-expression level, where some other JVM solutions (Kilim, Pulsar) do the same on byte code level. The main benefit of doing these transforms on s-expression level is that they are applicable to ClojureScript, where CSP can be a very neat way out of callback hell.
		
			<a href="https://martintrojer.github.io/post/2013-07-17-non-tailrecursive-functions-in-coreasync/">Read more...</a>
		
	</div>
</article>

		
			<article>
	<h1><a href="https://martintrojer.github.io/post/2013-07-07-coreasync-and-blocking-io/">core.async and Blocking IO</a></h1>
	<b><time>2013-07-07</time></b>
	
	<a href="/tags/clojure">clojure</a>
	
	<a href="/tags/core.async">core.async</a>
	
	<a href="/tags/go">go</a>
	
	<div>
		Some time ago I wrote about Asynchronous workflows in Clojure. With the recent release and excitement of core.async, I though it a good time to revisit that post.
While there are already some good example and comparison-with-go posts out there, I&rsquo;d like to focus on an area often misunderstood, namely async frameworks and blocking APIs (most commonly blocking IO). It&rsquo;s important to understand the implications of blocking IO and it&rsquo;s effects on &lsquo;async code&rsquo;, in this case core.
		
			<a href="https://martintrojer.github.io/post/2013-07-07-coreasync-and-blocking-io/">Read more...</a>
		
	</div>
</article>

		
			<article>
	<h1><a href="https://martintrojer.github.io/post/2013-07-05-datomic-bootstrap/">Datomic Bootstrap</a></h1>
	<b><time>2013-07-05</time></b>
	
	<a href="/tags/clojure">clojure</a>
	
	<a href="/tags/datomic">datomic</a>
	
	<div>
		<p>A simple SQL scenario;</p>
		
			<a href="https://martintrojer.github.io/post/2013-07-05-datomic-bootstrap/">Read more...</a>
		
	</div>
</article>

		
			<article>
	<h1><a href="https://martintrojer.github.io/post/2013-06-25-announcing-frins-a-practical-unit-of-measure-calculator-dsl-for-scala/">Announcing Frins, a practical unit of measure calculator DSL for Scala</a></h1>
	<b><time>2013-06-25</time></b>
	
	<a href="/tags/scala">scala</a>
	
	<a href="/tags/frinj">frinj</a>
	
	<a href="/tags/frins">frins</a>
	
	<div>
		I am proud to announce a new Scala project called &ldquo;Frins&rdquo;.
Frins is a practical unit-of-measure calculator DSL for Scala.
Key features;
Tracks units of measure through all calculations allowing you to mix units of measure transparently Comes with a huge database of units and conversion factors Inspired by the Frink project Full source code available on github.
To wet your appetite head straight over to the example calculations.
How Frins came about About a year ago I created Frinj.
		
			<a href="https://martintrojer.github.io/post/2013-06-25-announcing-frins-a-practical-unit-of-measure-calculator-dsl-for-scala/">Read more...</a>
		
	</div>
</article>

		
			<article>
	<h1><a href="https://martintrojer.github.io/post/2013-06-17-edn-parser-in-scala/">EDN Parser in Scala</a></h1>
	<b><time>2013-06-17</time></b>
	
	<a href="/tags/scala">scala</a>
	
	<div>
		<p>Taken from <a href="https://github.com/martintrojer/edn-scala">edn-scala</a></p>
		
			<a href="https://martintrojer.github.io/post/2013-06-17-edn-parser-in-scala/">Read more...</a>
		
	</div>
</article>

		
			<article>
	<h1><a href="https://martintrojer.github.io/post/2013-06-06-scheme-in-scala/">Scheme in Scala</a></h1>
	<b><time>2013-06-06</time></b>
	
	<a href="/tags/scala">scala</a>
	
	<a href="/tags/lisp">lisp</a>
	
	<div>
		In this post I present some of my experiences writing a Scheme interpreter in Scala (as an external DSL) and compare it with my recent similar experiences in Clojure and F#.
Overall, the Scala solution is very similar to the F# one. Not very surprising, since the problem lends itself well to case classes / discriminated union types and pattern matching. One difference is more type declarations in Scala, due to the lack of a Hindley-Milner type inference.
		
			<a href="https://martintrojer.github.io/post/2013-06-06-scheme-in-scala/">Read more...</a>
		
	</div>
</article>

		
			<article>
	<h1><a href="https://martintrojer.github.io/post/2013-06-04-comparing-fp-repl-sessions/">Comparing FP REPL Sessions</a></h1>
	<b><time>2013-06-04</time></b>
	
	<a href="/tags/scala">scala</a>
	
	<a href="/tags/clojure">clojure</a>
	
	<a href="/tags/fsharp">fsharp</a>
	
	<div>
		Functional programming is great; higher-order functions, closures, immutable data-structures, lazy sequences etc.
Most languages comes with a REPL (or &lsquo;interactive&rsquo; prompt), where you can play with these features at your leisure. Dynamically typed languages are a bit more convenient in the REPL, but not by as much as you might think. Also, F# type providers closes the gap even further.
Here&rsquo;s a typical, hit-a-JSON-endpoint-and-look-at-the-data session in Clojure;
$ lein repl user=&gt; (def res (slurp &#34;http://www.
		
			<a href="https://martintrojer.github.io/post/2013-06-04-comparing-fp-repl-sessions/">Read more...</a>
		
	</div>
</article>

		
			<article>
	<h1><a href="https://martintrojer.github.io/post/2013-06-01-scala-and-me/">Scala and me</a></h1>
	<b><time>2013-06-01</time></b>
	
	<a href="/tags/fsharp">fsharp</a>
	
	<a href="/tags/scala">scala</a>
	
	<a href="/tags/clojure">clojure</a>
	
	<a href="/tags/sicp">sicp</a>
	
	<div>
		This epic journey (yeah right) began at Uni with discovering the mighty SICP, still the best book on programming I&rsquo;ve read (and let&rsquo;s face it, the best I will ever read). After that profound experience I kept an eye on the Lisp/FP world and wrote some toys in Scheme, ELisp, OCaml every now and then. One thing that dawned on me was that none of these languages had much practical use, they weren&rsquo;t very applicable to real-world software problems.
		
			<a href="https://martintrojer.github.io/post/2013-06-01-scala-and-me/">Read more...</a>
		
	</div>
</article>

		
			<article>
	<h1><a href="https://martintrojer.github.io/post/2013-04-06-clojure-on-the-samsung-arm-chromebook/">Clojure Hacking on the Samsung ARM Chromebook</a></h1>
	<b><time>2013-04-06</time></b>
	
	<a href="/tags/clojure">clojure</a>
	
	<a href="/tags/chrome">chrome</a>
	
	<a href="/tags/arm">arm</a>
	
	<a href="/tags/rpi">rpi</a>
	
	<div>
		I recently switched to the Samsung ARM Chromebook for all my laptop needs. The pitch it&rsquo;s quite appealing, 200 quid, dual core ARM CortexA15s, good keyboard, totally fan-less (CPU is passively cooled), good battery life, 1kg weight. The one downside is it&rsquo;s quite limited RAM size, just 2GB. But with a decent swap file, I&rsquo;m running multiple JVMs (with Datomic, Elasicsearch, CLJS compiler etc without any hickups).
Out of the box it runs ChromeOS, which I have to say is pretty stellar for browsing and consuming content on the web.
		
			<a href="https://martintrojer.github.io/post/2013-04-06-clojure-on-the-samsung-arm-chromebook/">Read more...</a>
		
	</div>
</article>

		
		<div>

	<a href="/page/2/">Previous Page</a>

3 of 7

	<a href="/page/4/">Next Page</a>

</div>

	</main>

	<footer>
	<p>&copy; 2023 <a href="https://martintrojer.github.io/"><b>Martin Trojer</b></a>.
	<a href="https://github.com/martintrojer"><b>Github</b></a>.
	<a href="https://uk.linkedin.com/in/martintrojer"><b>LinkedIn</b></a>.
	</p>
</footer>

</body>
</html>
